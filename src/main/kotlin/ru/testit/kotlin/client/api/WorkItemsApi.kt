/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package ru.testit.kotlin.client.api

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import ru.testit.kotlin.client.models.AutoTestModel
import ru.testit.kotlin.client.models.IterationModel
import ru.testit.kotlin.client.models.SharedStepReferenceModel
import ru.testit.kotlin.client.models.SharedStepReferenceSectionModel
import ru.testit.kotlin.client.models.SharedStepReferenceSectionsQueryFilterModel
import ru.testit.kotlin.client.models.SharedStepReferencesQueryFilterModel
import ru.testit.kotlin.client.models.TestResultChronologyModel
import ru.testit.kotlin.client.models.TestResultHistoryReportModel
import ru.testit.kotlin.client.models.WorkItemChangeModel
import ru.testit.kotlin.client.models.WorkItemLikeModel
import ru.testit.kotlin.client.models.WorkItemModel
import ru.testit.kotlin.client.models.WorkItemMovePostModel
import ru.testit.kotlin.client.models.WorkItemPostModel
import ru.testit.kotlin.client.models.WorkItemPutModel
import ru.testit.kotlin.client.models.WorkItemSelectModel
import ru.testit.kotlin.client.models.WorkItemShortModel
import ru.testit.kotlin.client.models.WorkItemVersionModel

import ru.testit.kotlin.client.infrastructure.ApiClient
import ru.testit.kotlin.client.infrastructure.ApiResponse
import ru.testit.kotlin.client.infrastructure.ClientException
import ru.testit.kotlin.client.infrastructure.ClientError
import ru.testit.kotlin.client.infrastructure.ServerException
import ru.testit.kotlin.client.infrastructure.ServerError
import ru.testit.kotlin.client.infrastructure.MultiValueMap
import ru.testit.kotlin.client.infrastructure.PartConfig
import ru.testit.kotlin.client.infrastructure.RequestConfig
import ru.testit.kotlin.client.infrastructure.RequestMethod
import ru.testit.kotlin.client.infrastructure.ResponseType
import ru.testit.kotlin.client.infrastructure.Success
import ru.testit.kotlin.client.infrastructure.toMultiValue

class WorkItemsApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * Upload and link attachment to WorkItem
     *  Use case   User sets workItemId   User attaches a file   System creates attachment and links it to the work item   System returns attachment identifier
     * @param id Work item internal identifier (guid format)
     * @param file Select file (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2WorkItemsIdAttachmentsPost(id: java.util.UUID, file: java.io.File? = null) : Unit {
        val localVarResponse = apiV2WorkItemsIdAttachmentsPostWithHttpInfo(id = id, file = file)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Upload and link attachment to WorkItem
     *  Use case   User sets workItemId   User attaches a file   System creates attachment and links it to the work item   System returns attachment identifier
     * @param id Work item internal identifier (guid format)
     * @param file Select file (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2WorkItemsIdAttachmentsPostWithHttpInfo(id: java.util.UUID, file: java.io.File?) : ApiResponse<Unit?> {
        val localVariableConfig = apiV2WorkItemsIdAttachmentsPostRequestConfig(id = id, file = file)

        return request<Map<String, PartConfig<*>>, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2WorkItemsIdAttachmentsPost
     *
     * @param id Work item internal identifier (guid format)
     * @param file Select file (optional)
     * @return RequestConfig
     */
    fun apiV2WorkItemsIdAttachmentsPostRequestConfig(id: java.util.UUID, file: java.io.File?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "file" to PartConfig(body = file, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/workItems/{id}/attachments".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Transform CheckList to TestCase
     *  Use case   User sets checklist identifier   User runs method execution   System transform CheckList to TestCase
     * @param id 
     * @return WorkItemModel
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2WorkItemsIdCheckListTransformToTestCasePost(id: java.util.UUID) : WorkItemModel {
        val localVarResponse = apiV2WorkItemsIdCheckListTransformToTestCasePostWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as WorkItemModel
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Transform CheckList to TestCase
     *  Use case   User sets checklist identifier   User runs method execution   System transform CheckList to TestCase
     * @param id 
     * @return ApiResponse<WorkItemModel?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2WorkItemsIdCheckListTransformToTestCasePostWithHttpInfo(id: java.util.UUID) : ApiResponse<WorkItemModel?> {
        val localVariableConfig = apiV2WorkItemsIdCheckListTransformToTestCasePostRequestConfig(id = id)

        return request<Unit, WorkItemModel>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2WorkItemsIdCheckListTransformToTestCasePost
     *
     * @param id 
     * @return RequestConfig
     */
    fun apiV2WorkItemsIdCheckListTransformToTestCasePostRequestConfig(id: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/workItems/{id}/checkList/transformTo/testCase".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get change history of WorkItem
     *  Use case   User sets work item identifier   User runs method execution   System return change history of WorkItem
     * @param id 
     * @param skip Amount of items to be skipped (offset) (optional)
     * @param take Amount of items to be taken (limit) (optional)
     * @param orderBy SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC) (optional)
     * @param searchField Property name for searching (optional)
     * @param searchValue Value for searching (optional)
     * @return kotlin.collections.List<WorkItemChangeModel>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2WorkItemsIdHistoryGet(id: java.util.UUID, skip: kotlin.Int? = null, take: kotlin.Int? = null, orderBy: kotlin.String? = null, searchField: kotlin.String? = null, searchValue: kotlin.String? = null) : kotlin.collections.List<WorkItemChangeModel> {
        val localVarResponse = apiV2WorkItemsIdHistoryGetWithHttpInfo(id = id, skip = skip, take = take, orderBy = orderBy, searchField = searchField, searchValue = searchValue)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<WorkItemChangeModel>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get change history of WorkItem
     *  Use case   User sets work item identifier   User runs method execution   System return change history of WorkItem
     * @param id 
     * @param skip Amount of items to be skipped (offset) (optional)
     * @param take Amount of items to be taken (limit) (optional)
     * @param orderBy SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC) (optional)
     * @param searchField Property name for searching (optional)
     * @param searchValue Value for searching (optional)
     * @return ApiResponse<kotlin.collections.List<WorkItemChangeModel>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2WorkItemsIdHistoryGetWithHttpInfo(id: java.util.UUID, skip: kotlin.Int?, take: kotlin.Int?, orderBy: kotlin.String?, searchField: kotlin.String?, searchValue: kotlin.String?) : ApiResponse<kotlin.collections.List<WorkItemChangeModel>?> {
        val localVariableConfig = apiV2WorkItemsIdHistoryGetRequestConfig(id = id, skip = skip, take = take, orderBy = orderBy, searchField = searchField, searchValue = searchValue)

        return request<Unit, kotlin.collections.List<WorkItemChangeModel>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2WorkItemsIdHistoryGet
     *
     * @param id 
     * @param skip Amount of items to be skipped (offset) (optional)
     * @param take Amount of items to be taken (limit) (optional)
     * @param orderBy SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC) (optional)
     * @param searchField Property name for searching (optional)
     * @param searchValue Value for searching (optional)
     * @return RequestConfig
     */
    fun apiV2WorkItemsIdHistoryGetRequestConfig(id: java.util.UUID, skip: kotlin.Int?, take: kotlin.Int?, orderBy: kotlin.String?, searchField: kotlin.String?, searchValue: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (skip != null) {
                    put("Skip", listOf(skip.toString()))
                }
                if (take != null) {
                    put("Take", listOf(take.toString()))
                }
                if (orderBy != null) {
                    put("OrderBy", listOf(orderBy.toString()))
                }
                if (searchField != null) {
                    put("SearchField", listOf(searchField.toString()))
                }
                if (searchValue != null) {
                    put("SearchValue", listOf(searchValue.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/workItems/{id}/history".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Delete like from WorkItem
     *  Use case   User sets WorkItem identifier   User runs method execution   System delete like from WorkItem
     * @param id 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2WorkItemsIdLikeDelete(id: java.util.UUID) : Unit {
        val localVarResponse = apiV2WorkItemsIdLikeDeleteWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete like from WorkItem
     *  Use case   User sets WorkItem identifier   User runs method execution   System delete like from WorkItem
     * @param id 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2WorkItemsIdLikeDeleteWithHttpInfo(id: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = apiV2WorkItemsIdLikeDeleteRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2WorkItemsIdLikeDelete
     *
     * @param id 
     * @return RequestConfig
     */
    fun apiV2WorkItemsIdLikeDeleteRequestConfig(id: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/workItems/{id}/like".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Set like to WorkItem
     *  Use case   User sets WorkItem identifier   User runs method execution   System set like to WorkItem
     * @param id 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2WorkItemsIdLikePost(id: java.util.UUID) : Unit {
        val localVarResponse = apiV2WorkItemsIdLikePostWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Set like to WorkItem
     *  Use case   User sets WorkItem identifier   User runs method execution   System set like to WorkItem
     * @param id 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2WorkItemsIdLikePostWithHttpInfo(id: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = apiV2WorkItemsIdLikePostRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2WorkItemsIdLikePost
     *
     * @param id 
     * @return RequestConfig
     */
    fun apiV2WorkItemsIdLikePostRequestConfig(id: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/workItems/{id}/like".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get likes count of WorkItem
     *  Use case   User sets WorkItem identifier   User runs method execution   System return likes count of WorkItem
     * @param id 
     * @return kotlin.Int
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2WorkItemsIdLikesCountGet(id: java.util.UUID) : kotlin.Int {
        val localVarResponse = apiV2WorkItemsIdLikesCountGetWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Int
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get likes count of WorkItem
     *  Use case   User sets WorkItem identifier   User runs method execution   System return likes count of WorkItem
     * @param id 
     * @return ApiResponse<kotlin.Int?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2WorkItemsIdLikesCountGetWithHttpInfo(id: java.util.UUID) : ApiResponse<kotlin.Int?> {
        val localVariableConfig = apiV2WorkItemsIdLikesCountGetRequestConfig(id = id)

        return request<Unit, kotlin.Int>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2WorkItemsIdLikesCountGet
     *
     * @param id 
     * @return RequestConfig
     */
    fun apiV2WorkItemsIdLikesCountGetRequestConfig(id: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/workItems/{id}/likes/count".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get likes of WorkItem
     *  Use case   User sets WorkItem identifier   User runs method execution   System return likes of WorkItem
     * @param id 
     * @return kotlin.collections.List<WorkItemLikeModel>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2WorkItemsIdLikesGet(id: java.util.UUID) : kotlin.collections.List<WorkItemLikeModel> {
        val localVarResponse = apiV2WorkItemsIdLikesGetWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<WorkItemLikeModel>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get likes of WorkItem
     *  Use case   User sets WorkItem identifier   User runs method execution   System return likes of WorkItem
     * @param id 
     * @return ApiResponse<kotlin.collections.List<WorkItemLikeModel>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2WorkItemsIdLikesGetWithHttpInfo(id: java.util.UUID) : ApiResponse<kotlin.collections.List<WorkItemLikeModel>?> {
        val localVariableConfig = apiV2WorkItemsIdLikesGetRequestConfig(id = id)

        return request<Unit, kotlin.collections.List<WorkItemLikeModel>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2WorkItemsIdLikesGet
     *
     * @param id 
     * @return RequestConfig
     */
    fun apiV2WorkItemsIdLikesGetRequestConfig(id: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/workItems/{id}/likes".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get test results history of WorkItem
     *  Use case   User sets WorkItem identifier   User runs method execution   System return test results history of WorkItem
     * @param id 
     * @param from Take results from this date (optional)
     * @param to Take results until this date (optional)
     * @param configurationIds Identifiers of test result configurations (optional)
     * @param testPlanIds Identifiers of test plans which contain test results (optional)
     * @param userIds Identifiers of users who set test results (optional)
     * @param outcomes List of outcomes of test results (optional)
     * @param isAutomated OBSOLETE: Use &#x60;Automated&#x60; instead (optional)
     * @param automated If result must consist of only manual/automated test results (optional)
     * @param testRunIds Identifiers of test runs which contain test results (optional)
     * @param skip Amount of items to be skipped (offset) (optional)
     * @param take Amount of items to be taken (limit) (optional)
     * @param orderBy SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC) (optional)
     * @param searchField Property name for searching (optional)
     * @param searchValue Value for searching (optional)
     * @return kotlin.collections.List<TestResultHistoryReportModel>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2WorkItemsIdTestResultsHistoryGet(id: java.util.UUID, from: java.time.OffsetDateTime? = null, to: java.time.OffsetDateTime? = null, configurationIds: kotlin.collections.List<java.util.UUID>? = null, testPlanIds: kotlin.collections.List<java.util.UUID>? = null, userIds: kotlin.collections.List<java.util.UUID>? = null, outcomes: kotlin.collections.List<kotlin.String>? = null, isAutomated: kotlin.Boolean? = null, automated: kotlin.Boolean? = null, testRunIds: kotlin.collections.List<java.util.UUID>? = null, skip: kotlin.Int? = null, take: kotlin.Int? = null, orderBy: kotlin.String? = null, searchField: kotlin.String? = null, searchValue: kotlin.String? = null) : kotlin.collections.List<TestResultHistoryReportModel> {
        val localVarResponse = apiV2WorkItemsIdTestResultsHistoryGetWithHttpInfo(id = id, from = from, to = to, configurationIds = configurationIds, testPlanIds = testPlanIds, userIds = userIds, outcomes = outcomes, isAutomated = isAutomated, automated = automated, testRunIds = testRunIds, skip = skip, take = take, orderBy = orderBy, searchField = searchField, searchValue = searchValue)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<TestResultHistoryReportModel>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get test results history of WorkItem
     *  Use case   User sets WorkItem identifier   User runs method execution   System return test results history of WorkItem
     * @param id 
     * @param from Take results from this date (optional)
     * @param to Take results until this date (optional)
     * @param configurationIds Identifiers of test result configurations (optional)
     * @param testPlanIds Identifiers of test plans which contain test results (optional)
     * @param userIds Identifiers of users who set test results (optional)
     * @param outcomes List of outcomes of test results (optional)
     * @param isAutomated OBSOLETE: Use &#x60;Automated&#x60; instead (optional)
     * @param automated If result must consist of only manual/automated test results (optional)
     * @param testRunIds Identifiers of test runs which contain test results (optional)
     * @param skip Amount of items to be skipped (offset) (optional)
     * @param take Amount of items to be taken (limit) (optional)
     * @param orderBy SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC) (optional)
     * @param searchField Property name for searching (optional)
     * @param searchValue Value for searching (optional)
     * @return ApiResponse<kotlin.collections.List<TestResultHistoryReportModel>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2WorkItemsIdTestResultsHistoryGetWithHttpInfo(id: java.util.UUID, from: java.time.OffsetDateTime?, to: java.time.OffsetDateTime?, configurationIds: kotlin.collections.List<java.util.UUID>?, testPlanIds: kotlin.collections.List<java.util.UUID>?, userIds: kotlin.collections.List<java.util.UUID>?, outcomes: kotlin.collections.List<kotlin.String>?, isAutomated: kotlin.Boolean?, automated: kotlin.Boolean?, testRunIds: kotlin.collections.List<java.util.UUID>?, skip: kotlin.Int?, take: kotlin.Int?, orderBy: kotlin.String?, searchField: kotlin.String?, searchValue: kotlin.String?) : ApiResponse<kotlin.collections.List<TestResultHistoryReportModel>?> {
        val localVariableConfig = apiV2WorkItemsIdTestResultsHistoryGetRequestConfig(id = id, from = from, to = to, configurationIds = configurationIds, testPlanIds = testPlanIds, userIds = userIds, outcomes = outcomes, isAutomated = isAutomated, automated = automated, testRunIds = testRunIds, skip = skip, take = take, orderBy = orderBy, searchField = searchField, searchValue = searchValue)

        return request<Unit, kotlin.collections.List<TestResultHistoryReportModel>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2WorkItemsIdTestResultsHistoryGet
     *
     * @param id 
     * @param from Take results from this date (optional)
     * @param to Take results until this date (optional)
     * @param configurationIds Identifiers of test result configurations (optional)
     * @param testPlanIds Identifiers of test plans which contain test results (optional)
     * @param userIds Identifiers of users who set test results (optional)
     * @param outcomes List of outcomes of test results (optional)
     * @param isAutomated OBSOLETE: Use &#x60;Automated&#x60; instead (optional)
     * @param automated If result must consist of only manual/automated test results (optional)
     * @param testRunIds Identifiers of test runs which contain test results (optional)
     * @param skip Amount of items to be skipped (offset) (optional)
     * @param take Amount of items to be taken (limit) (optional)
     * @param orderBy SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC) (optional)
     * @param searchField Property name for searching (optional)
     * @param searchValue Value for searching (optional)
     * @return RequestConfig
     */
    fun apiV2WorkItemsIdTestResultsHistoryGetRequestConfig(id: java.util.UUID, from: java.time.OffsetDateTime?, to: java.time.OffsetDateTime?, configurationIds: kotlin.collections.List<java.util.UUID>?, testPlanIds: kotlin.collections.List<java.util.UUID>?, userIds: kotlin.collections.List<java.util.UUID>?, outcomes: kotlin.collections.List<kotlin.String>?, isAutomated: kotlin.Boolean?, automated: kotlin.Boolean?, testRunIds: kotlin.collections.List<java.util.UUID>?, skip: kotlin.Int?, take: kotlin.Int?, orderBy: kotlin.String?, searchField: kotlin.String?, searchValue: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (from != null) {
                    put("from", listOf(parseDateToQueryString(from)))
                }
                if (to != null) {
                    put("to", listOf(parseDateToQueryString(to)))
                }
                if (configurationIds != null) {
                    put("configurationIds", toMultiValue(configurationIds.toList(), "multi"))
                }
                if (testPlanIds != null) {
                    put("testPlanIds", toMultiValue(testPlanIds.toList(), "multi"))
                }
                if (userIds != null) {
                    put("userIds", toMultiValue(userIds.toList(), "multi"))
                }
                if (outcomes != null) {
                    put("outcomes", toMultiValue(outcomes.toList(), "multi"))
                }
                if (isAutomated != null) {
                    put("isAutomated", listOf(isAutomated.toString()))
                }
                if (automated != null) {
                    put("automated", listOf(automated.toString()))
                }
                if (testRunIds != null) {
                    put("testRunIds", toMultiValue(testRunIds.toList(), "multi"))
                }
                if (skip != null) {
                    put("Skip", listOf(skip.toString()))
                }
                if (take != null) {
                    put("Take", listOf(take.toString()))
                }
                if (orderBy != null) {
                    put("OrderBy", listOf(orderBy.toString()))
                }
                if (searchField != null) {
                    put("SearchField", listOf(searchField.toString()))
                }
                if (searchValue != null) {
                    put("SearchValue", listOf(searchValue.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/workItems/{id}/testResults/history".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Set WorkItem as actual
     *  Use case   User sets work item identifier   User runs method execution   System set WorkItem as actual
     * @param id 
     * @param versionId 
     * @return WorkItemModel
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2WorkItemsIdVersionVersionIdActualPost(id: java.util.UUID, versionId: java.util.UUID) : WorkItemModel {
        val localVarResponse = apiV2WorkItemsIdVersionVersionIdActualPostWithHttpInfo(id = id, versionId = versionId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as WorkItemModel
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Set WorkItem as actual
     *  Use case   User sets work item identifier   User runs method execution   System set WorkItem as actual
     * @param id 
     * @param versionId 
     * @return ApiResponse<WorkItemModel?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2WorkItemsIdVersionVersionIdActualPostWithHttpInfo(id: java.util.UUID, versionId: java.util.UUID) : ApiResponse<WorkItemModel?> {
        val localVariableConfig = apiV2WorkItemsIdVersionVersionIdActualPostRequestConfig(id = id, versionId = versionId)

        return request<Unit, WorkItemModel>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2WorkItemsIdVersionVersionIdActualPost
     *
     * @param id 
     * @param versionId 
     * @return RequestConfig
     */
    fun apiV2WorkItemsIdVersionVersionIdActualPostRequestConfig(id: java.util.UUID, versionId: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/workItems/{id}/version/{versionId}/actual".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"versionId"+"}", encodeURIComponent(versionId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Move WorkItem to another section
     *  Use case   User sets WorkItem identifier   User runs method execution   System move WorkItem to another section
     * @param workItemMovePostModel  (optional)
     * @return WorkItemShortModel
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2WorkItemsMovePost(workItemMovePostModel: WorkItemMovePostModel? = null) : WorkItemShortModel {
        val localVarResponse = apiV2WorkItemsMovePostWithHttpInfo(workItemMovePostModel = workItemMovePostModel)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as WorkItemShortModel
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Move WorkItem to another section
     *  Use case   User sets WorkItem identifier   User runs method execution   System move WorkItem to another section
     * @param workItemMovePostModel  (optional)
     * @return ApiResponse<WorkItemShortModel?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2WorkItemsMovePostWithHttpInfo(workItemMovePostModel: WorkItemMovePostModel?) : ApiResponse<WorkItemShortModel?> {
        val localVariableConfig = apiV2WorkItemsMovePostRequestConfig(workItemMovePostModel = workItemMovePostModel)

        return request<WorkItemMovePostModel, WorkItemShortModel>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2WorkItemsMovePost
     *
     * @param workItemMovePostModel  (optional)
     * @return RequestConfig
     */
    fun apiV2WorkItemsMovePostRequestConfig(workItemMovePostModel: WorkItemMovePostModel?) : RequestConfig<WorkItemMovePostModel> {
        val localVariableBody = workItemMovePostModel
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/workItems/move",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Search for work items
     * 
     * @param skip Amount of items to be skipped (offset) (optional)
     * @param take Amount of items to be taken (limit) (optional)
     * @param orderBy SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC) (optional)
     * @param searchField Property name for searching (optional)
     * @param searchValue Value for searching (optional)
     * @param workItemSelectModel  (optional)
     * @return kotlin.collections.List<WorkItemShortModel>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2WorkItemsSearchPost(skip: kotlin.Int? = null, take: kotlin.Int? = null, orderBy: kotlin.String? = null, searchField: kotlin.String? = null, searchValue: kotlin.String? = null, workItemSelectModel: WorkItemSelectModel? = null) : kotlin.collections.List<WorkItemShortModel> {
        val localVarResponse = apiV2WorkItemsSearchPostWithHttpInfo(skip = skip, take = take, orderBy = orderBy, searchField = searchField, searchValue = searchValue, workItemSelectModel = workItemSelectModel)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<WorkItemShortModel>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Search for work items
     * 
     * @param skip Amount of items to be skipped (offset) (optional)
     * @param take Amount of items to be taken (limit) (optional)
     * @param orderBy SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC) (optional)
     * @param searchField Property name for searching (optional)
     * @param searchValue Value for searching (optional)
     * @param workItemSelectModel  (optional)
     * @return ApiResponse<kotlin.collections.List<WorkItemShortModel>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2WorkItemsSearchPostWithHttpInfo(skip: kotlin.Int?, take: kotlin.Int?, orderBy: kotlin.String?, searchField: kotlin.String?, searchValue: kotlin.String?, workItemSelectModel: WorkItemSelectModel?) : ApiResponse<kotlin.collections.List<WorkItemShortModel>?> {
        val localVariableConfig = apiV2WorkItemsSearchPostRequestConfig(skip = skip, take = take, orderBy = orderBy, searchField = searchField, searchValue = searchValue, workItemSelectModel = workItemSelectModel)

        return request<WorkItemSelectModel, kotlin.collections.List<WorkItemShortModel>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2WorkItemsSearchPost
     *
     * @param skip Amount of items to be skipped (offset) (optional)
     * @param take Amount of items to be taken (limit) (optional)
     * @param orderBy SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC) (optional)
     * @param searchField Property name for searching (optional)
     * @param searchValue Value for searching (optional)
     * @param workItemSelectModel  (optional)
     * @return RequestConfig
     */
    fun apiV2WorkItemsSearchPostRequestConfig(skip: kotlin.Int?, take: kotlin.Int?, orderBy: kotlin.String?, searchField: kotlin.String?, searchValue: kotlin.String?, workItemSelectModel: WorkItemSelectModel?) : RequestConfig<WorkItemSelectModel> {
        val localVariableBody = workItemSelectModel
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (skip != null) {
                    put("Skip", listOf(skip.toString()))
                }
                if (take != null) {
                    put("Take", listOf(take.toString()))
                }
                if (orderBy != null) {
                    put("OrderBy", listOf(orderBy.toString()))
                }
                if (searchField != null) {
                    put("SearchField", listOf(searchField.toString()))
                }
                if (searchValue != null) {
                    put("SearchValue", listOf(searchValue.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/workItems/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get SharedStep references in sections
     *  Use case   User sets SharedStep identifier   User runs method execution   System return SharedStep references
     * @param sharedStepId 
     * @param skip Amount of items to be skipped (offset) (optional)
     * @param take Amount of items to be taken (limit) (optional)
     * @param orderBy SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC) (optional)
     * @param searchField Property name for searching (optional)
     * @param searchValue Value for searching (optional)
     * @param sharedStepReferenceSectionsQueryFilterModel  (optional)
     * @return kotlin.collections.List<SharedStepReferenceSectionModel>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2WorkItemsSharedStepIdReferencesSectionsPost(sharedStepId: java.util.UUID, skip: kotlin.Int? = null, take: kotlin.Int? = null, orderBy: kotlin.String? = null, searchField: kotlin.String? = null, searchValue: kotlin.String? = null, sharedStepReferenceSectionsQueryFilterModel: SharedStepReferenceSectionsQueryFilterModel? = null) : kotlin.collections.List<SharedStepReferenceSectionModel> {
        val localVarResponse = apiV2WorkItemsSharedStepIdReferencesSectionsPostWithHttpInfo(sharedStepId = sharedStepId, skip = skip, take = take, orderBy = orderBy, searchField = searchField, searchValue = searchValue, sharedStepReferenceSectionsQueryFilterModel = sharedStepReferenceSectionsQueryFilterModel)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<SharedStepReferenceSectionModel>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get SharedStep references in sections
     *  Use case   User sets SharedStep identifier   User runs method execution   System return SharedStep references
     * @param sharedStepId 
     * @param skip Amount of items to be skipped (offset) (optional)
     * @param take Amount of items to be taken (limit) (optional)
     * @param orderBy SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC) (optional)
     * @param searchField Property name for searching (optional)
     * @param searchValue Value for searching (optional)
     * @param sharedStepReferenceSectionsQueryFilterModel  (optional)
     * @return ApiResponse<kotlin.collections.List<SharedStepReferenceSectionModel>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2WorkItemsSharedStepIdReferencesSectionsPostWithHttpInfo(sharedStepId: java.util.UUID, skip: kotlin.Int?, take: kotlin.Int?, orderBy: kotlin.String?, searchField: kotlin.String?, searchValue: kotlin.String?, sharedStepReferenceSectionsQueryFilterModel: SharedStepReferenceSectionsQueryFilterModel?) : ApiResponse<kotlin.collections.List<SharedStepReferenceSectionModel>?> {
        val localVariableConfig = apiV2WorkItemsSharedStepIdReferencesSectionsPostRequestConfig(sharedStepId = sharedStepId, skip = skip, take = take, orderBy = orderBy, searchField = searchField, searchValue = searchValue, sharedStepReferenceSectionsQueryFilterModel = sharedStepReferenceSectionsQueryFilterModel)

        return request<SharedStepReferenceSectionsQueryFilterModel, kotlin.collections.List<SharedStepReferenceSectionModel>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2WorkItemsSharedStepIdReferencesSectionsPost
     *
     * @param sharedStepId 
     * @param skip Amount of items to be skipped (offset) (optional)
     * @param take Amount of items to be taken (limit) (optional)
     * @param orderBy SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC) (optional)
     * @param searchField Property name for searching (optional)
     * @param searchValue Value for searching (optional)
     * @param sharedStepReferenceSectionsQueryFilterModel  (optional)
     * @return RequestConfig
     */
    fun apiV2WorkItemsSharedStepIdReferencesSectionsPostRequestConfig(sharedStepId: java.util.UUID, skip: kotlin.Int?, take: kotlin.Int?, orderBy: kotlin.String?, searchField: kotlin.String?, searchValue: kotlin.String?, sharedStepReferenceSectionsQueryFilterModel: SharedStepReferenceSectionsQueryFilterModel?) : RequestConfig<SharedStepReferenceSectionsQueryFilterModel> {
        val localVariableBody = sharedStepReferenceSectionsQueryFilterModel
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (skip != null) {
                    put("Skip", listOf(skip.toString()))
                }
                if (take != null) {
                    put("Take", listOf(take.toString()))
                }
                if (orderBy != null) {
                    put("OrderBy", listOf(orderBy.toString()))
                }
                if (searchField != null) {
                    put("SearchField", listOf(searchField.toString()))
                }
                if (searchValue != null) {
                    put("SearchValue", listOf(searchValue.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/workItems/{sharedStepId}/references/sections".replace("{"+"sharedStepId"+"}", encodeURIComponent(sharedStepId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get SharedStep references in work items
     *  Use case   User sets SharedStep identifier   User runs method execution   System return SharedStep references
     * @param sharedStepId 
     * @param skip Amount of items to be skipped (offset) (optional)
     * @param take Amount of items to be taken (limit) (optional)
     * @param orderBy SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC) (optional)
     * @param searchField Property name for searching (optional)
     * @param searchValue Value for searching (optional)
     * @param sharedStepReferencesQueryFilterModel  (optional)
     * @return kotlin.collections.List<SharedStepReferenceModel>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2WorkItemsSharedStepIdReferencesWorkItemsPost(sharedStepId: java.util.UUID, skip: kotlin.Int? = null, take: kotlin.Int? = null, orderBy: kotlin.String? = null, searchField: kotlin.String? = null, searchValue: kotlin.String? = null, sharedStepReferencesQueryFilterModel: SharedStepReferencesQueryFilterModel? = null) : kotlin.collections.List<SharedStepReferenceModel> {
        val localVarResponse = apiV2WorkItemsSharedStepIdReferencesWorkItemsPostWithHttpInfo(sharedStepId = sharedStepId, skip = skip, take = take, orderBy = orderBy, searchField = searchField, searchValue = searchValue, sharedStepReferencesQueryFilterModel = sharedStepReferencesQueryFilterModel)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<SharedStepReferenceModel>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get SharedStep references in work items
     *  Use case   User sets SharedStep identifier   User runs method execution   System return SharedStep references
     * @param sharedStepId 
     * @param skip Amount of items to be skipped (offset) (optional)
     * @param take Amount of items to be taken (limit) (optional)
     * @param orderBy SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC) (optional)
     * @param searchField Property name for searching (optional)
     * @param searchValue Value for searching (optional)
     * @param sharedStepReferencesQueryFilterModel  (optional)
     * @return ApiResponse<kotlin.collections.List<SharedStepReferenceModel>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2WorkItemsSharedStepIdReferencesWorkItemsPostWithHttpInfo(sharedStepId: java.util.UUID, skip: kotlin.Int?, take: kotlin.Int?, orderBy: kotlin.String?, searchField: kotlin.String?, searchValue: kotlin.String?, sharedStepReferencesQueryFilterModel: SharedStepReferencesQueryFilterModel?) : ApiResponse<kotlin.collections.List<SharedStepReferenceModel>?> {
        val localVariableConfig = apiV2WorkItemsSharedStepIdReferencesWorkItemsPostRequestConfig(sharedStepId = sharedStepId, skip = skip, take = take, orderBy = orderBy, searchField = searchField, searchValue = searchValue, sharedStepReferencesQueryFilterModel = sharedStepReferencesQueryFilterModel)

        return request<SharedStepReferencesQueryFilterModel, kotlin.collections.List<SharedStepReferenceModel>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2WorkItemsSharedStepIdReferencesWorkItemsPost
     *
     * @param sharedStepId 
     * @param skip Amount of items to be skipped (offset) (optional)
     * @param take Amount of items to be taken (limit) (optional)
     * @param orderBy SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC) (optional)
     * @param searchField Property name for searching (optional)
     * @param searchValue Value for searching (optional)
     * @param sharedStepReferencesQueryFilterModel  (optional)
     * @return RequestConfig
     */
    fun apiV2WorkItemsSharedStepIdReferencesWorkItemsPostRequestConfig(sharedStepId: java.util.UUID, skip: kotlin.Int?, take: kotlin.Int?, orderBy: kotlin.String?, searchField: kotlin.String?, searchValue: kotlin.String?, sharedStepReferencesQueryFilterModel: SharedStepReferencesQueryFilterModel?) : RequestConfig<SharedStepReferencesQueryFilterModel> {
        val localVariableBody = sharedStepReferencesQueryFilterModel
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (skip != null) {
                    put("Skip", listOf(skip.toString()))
                }
                if (take != null) {
                    put("Take", listOf(take.toString()))
                }
                if (orderBy != null) {
                    put("OrderBy", listOf(orderBy.toString()))
                }
                if (searchField != null) {
                    put("SearchField", listOf(searchField.toString()))
                }
                if (searchValue != null) {
                    put("SearchValue", listOf(searchValue.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/workItems/{sharedStepId}/references/workItems".replace("{"+"sharedStepId"+"}", encodeURIComponent(sharedStepId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get SharedStep references
     *  Use case   User sets SharedStep identifier   User runs method execution   System return SharedStep references
     * @param sharedStepId 
     * @return kotlin.collections.List<SharedStepReferenceModel>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    @Deprecated(message = "This operation is deprecated.")
    fun apiV2WorkItemsSharedStepsSharedStepIdReferencesGet(sharedStepId: java.util.UUID) : kotlin.collections.List<SharedStepReferenceModel> {
        @Suppress("DEPRECATION")
        val localVarResponse = apiV2WorkItemsSharedStepsSharedStepIdReferencesGetWithHttpInfo(sharedStepId = sharedStepId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<SharedStepReferenceModel>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get SharedStep references
     *  Use case   User sets SharedStep identifier   User runs method execution   System return SharedStep references
     * @param sharedStepId 
     * @return ApiResponse<kotlin.collections.List<SharedStepReferenceModel>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    @Deprecated(message = "This operation is deprecated.")
    fun apiV2WorkItemsSharedStepsSharedStepIdReferencesGetWithHttpInfo(sharedStepId: java.util.UUID) : ApiResponse<kotlin.collections.List<SharedStepReferenceModel>?> {
        @Suppress("DEPRECATION")
        val localVariableConfig = apiV2WorkItemsSharedStepsSharedStepIdReferencesGetRequestConfig(sharedStepId = sharedStepId)

        return request<Unit, kotlin.collections.List<SharedStepReferenceModel>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2WorkItemsSharedStepsSharedStepIdReferencesGet
     *
     * @param sharedStepId 
     * @return RequestConfig
     */
    @Deprecated(message = "This operation is deprecated.")
    fun apiV2WorkItemsSharedStepsSharedStepIdReferencesGetRequestConfig(sharedStepId: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/workItems/sharedSteps/{sharedStepId}/references".replace("{"+"sharedStepId"+"}", encodeURIComponent(sharedStepId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Create Test Case, Checklist or Shared Step
     *  Use case   User sets work item properties (listed in request parameters)   User runs method execution   System creates work item by identifier   System returns work item model (listed in response parameters)
     * @param workItemPostModel  (optional)
     * @return WorkItemModel
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createWorkItem(workItemPostModel: WorkItemPostModel? = null) : WorkItemModel {
        val localVarResponse = createWorkItemWithHttpInfo(workItemPostModel = workItemPostModel)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as WorkItemModel
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create Test Case, Checklist or Shared Step
     *  Use case   User sets work item properties (listed in request parameters)   User runs method execution   System creates work item by identifier   System returns work item model (listed in response parameters)
     * @param workItemPostModel  (optional)
     * @return ApiResponse<WorkItemModel?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createWorkItemWithHttpInfo(workItemPostModel: WorkItemPostModel?) : ApiResponse<WorkItemModel?> {
        val localVariableConfig = createWorkItemRequestConfig(workItemPostModel = workItemPostModel)

        return request<WorkItemPostModel, WorkItemModel>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createWorkItem
     *
     * @param workItemPostModel  (optional)
     * @return RequestConfig
     */
    fun createWorkItemRequestConfig(workItemPostModel: WorkItemPostModel?) : RequestConfig<WorkItemPostModel> {
        val localVariableBody = workItemPostModel
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/workItems",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Delete all links AutoTests from WorkItem by Id or GlobalId
     *  Use case   User sets work item identifier   User runs method execution   System search work item by identifier   System search and delete all autotests, related to found work item   System returns no content response
     * @param id WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteAllWorkItemsFromAutoTest(id: kotlin.String) : Unit {
        val localVarResponse = deleteAllWorkItemsFromAutoTestWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete all links AutoTests from WorkItem by Id or GlobalId
     *  Use case   User sets work item identifier   User runs method execution   System search work item by identifier   System search and delete all autotests, related to found work item   System returns no content response
     * @param id WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteAllWorkItemsFromAutoTestWithHttpInfo(id: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = deleteAllWorkItemsFromAutoTestRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteAllWorkItemsFromAutoTest
     *
     * @param id WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @return RequestConfig
     */
    fun deleteAllWorkItemsFromAutoTestRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/workItems/{id}/autoTests".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Delete Test Case, Checklist or Shared Step by Id or GlobalId
     *  Use case   User sets work item identifier   User runs method execution   System deletes work item   System returns no content response
     * @param id WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteWorkItem(id: kotlin.String) : Unit {
        val localVarResponse = deleteWorkItemWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete Test Case, Checklist or Shared Step by Id or GlobalId
     *  Use case   User sets work item identifier   User runs method execution   System deletes work item   System returns no content response
     * @param id WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteWorkItemWithHttpInfo(id: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = deleteWorkItemRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteWorkItem
     *
     * @param id WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @return RequestConfig
     */
    fun deleteWorkItemRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/workItems/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get all AutoTests linked to WorkItem by Id or GlobalId
     *  Use case   User sets work item identifier   User runs method execution   System search work item by identifier   System search all autotests, related to found work item   System returns list of found autotests
     * @param id WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @return kotlin.collections.List<AutoTestModel>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAutoTestsForWorkItem(id: kotlin.String) : kotlin.collections.List<AutoTestModel> {
        val localVarResponse = getAutoTestsForWorkItemWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<AutoTestModel>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get all AutoTests linked to WorkItem by Id or GlobalId
     *  Use case   User sets work item identifier   User runs method execution   System search work item by identifier   System search all autotests, related to found work item   System returns list of found autotests
     * @param id WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @return ApiResponse<kotlin.collections.List<AutoTestModel>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAutoTestsForWorkItemWithHttpInfo(id: kotlin.String) : ApiResponse<kotlin.collections.List<AutoTestModel>?> {
        val localVariableConfig = getAutoTestsForWorkItemRequestConfig(id = id)

        return request<Unit, kotlin.collections.List<AutoTestModel>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAutoTestsForWorkItem
     *
     * @param id WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @return RequestConfig
     */
    fun getAutoTestsForWorkItemRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/workItems/{id}/autoTests".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get iterations by work item Id or GlobalId
     * 
     * @param id WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @param versionId WorkItem version (guid format) identifier (optional)
     * @param versionNumber WorkItem version number (0 is the last version)\&quot; (optional)
     * @return kotlin.collections.List<IterationModel>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getIterations(id: kotlin.String, versionId: java.util.UUID? = null, versionNumber: kotlin.Int? = null) : kotlin.collections.List<IterationModel> {
        val localVarResponse = getIterationsWithHttpInfo(id = id, versionId = versionId, versionNumber = versionNumber)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<IterationModel>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get iterations by work item Id or GlobalId
     * 
     * @param id WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @param versionId WorkItem version (guid format) identifier (optional)
     * @param versionNumber WorkItem version number (0 is the last version)\&quot; (optional)
     * @return ApiResponse<kotlin.collections.List<IterationModel>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getIterationsWithHttpInfo(id: kotlin.String, versionId: java.util.UUID?, versionNumber: kotlin.Int?) : ApiResponse<kotlin.collections.List<IterationModel>?> {
        val localVariableConfig = getIterationsRequestConfig(id = id, versionId = versionId, versionNumber = versionNumber)

        return request<Unit, kotlin.collections.List<IterationModel>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getIterations
     *
     * @param id WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @param versionId WorkItem version (guid format) identifier (optional)
     * @param versionNumber WorkItem version number (0 is the last version)\&quot; (optional)
     * @return RequestConfig
     */
    fun getIterationsRequestConfig(id: kotlin.String, versionId: java.util.UUID?, versionNumber: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (versionId != null) {
                    put("versionId", listOf(versionId.toString()))
                }
                if (versionNumber != null) {
                    put("versionNumber", listOf(versionNumber.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/workItems/{id}/iterations".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Test Case, Checklist or Shared Step by Id or GlobalId
     *  Use case   User sets work item identifier   [Optional] User sets work item version identifier   [Optional] User sets work item version number   User runs method execution   System search work item by identifier   [Optional] if User sets work item version identifier, system search work item version by identifier.   [Optional] if user sets work item version number, system search work item version by number   Otherwise, system search last work item version   System returns work item 
     * @param id WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @param versionId WorkItem version (guid format) identifier\&quot; (optional)
     * @param versionNumber WorkItem version number (0 is the last version)\&quot; (optional)
     * @return WorkItemModel
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getWorkItemById(id: kotlin.String, versionId: java.util.UUID? = null, versionNumber: kotlin.Int? = null) : WorkItemModel {
        val localVarResponse = getWorkItemByIdWithHttpInfo(id = id, versionId = versionId, versionNumber = versionNumber)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as WorkItemModel
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Test Case, Checklist or Shared Step by Id or GlobalId
     *  Use case   User sets work item identifier   [Optional] User sets work item version identifier   [Optional] User sets work item version number   User runs method execution   System search work item by identifier   [Optional] if User sets work item version identifier, system search work item version by identifier.   [Optional] if user sets work item version number, system search work item version by number   Otherwise, system search last work item version   System returns work item 
     * @param id WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @param versionId WorkItem version (guid format) identifier\&quot; (optional)
     * @param versionNumber WorkItem version number (0 is the last version)\&quot; (optional)
     * @return ApiResponse<WorkItemModel?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getWorkItemByIdWithHttpInfo(id: kotlin.String, versionId: java.util.UUID?, versionNumber: kotlin.Int?) : ApiResponse<WorkItemModel?> {
        val localVariableConfig = getWorkItemByIdRequestConfig(id = id, versionId = versionId, versionNumber = versionNumber)

        return request<Unit, WorkItemModel>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getWorkItemById
     *
     * @param id WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @param versionId WorkItem version (guid format) identifier\&quot; (optional)
     * @param versionNumber WorkItem version number (0 is the last version)\&quot; (optional)
     * @return RequestConfig
     */
    fun getWorkItemByIdRequestConfig(id: kotlin.String, versionId: java.util.UUID?, versionNumber: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (versionId != null) {
                    put("versionId", listOf(versionId.toString()))
                }
                if (versionNumber != null) {
                    put("versionNumber", listOf(versionNumber.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/workItems/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get WorkItem chronology by Id or GlobalId
     *  Use case   User sets work item identifier   User runs method execution   System search work item by identifier   System search test results of all autotests, related to found work item   System sort results by CompletedOn ascending, then by CreatedDate ascending   System returns sorted collection of test results
     * @param id 
     * @return kotlin.collections.List<TestResultChronologyModel>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getWorkItemChronology(id: kotlin.String) : kotlin.collections.List<TestResultChronologyModel> {
        val localVarResponse = getWorkItemChronologyWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<TestResultChronologyModel>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get WorkItem chronology by Id or GlobalId
     *  Use case   User sets work item identifier   User runs method execution   System search work item by identifier   System search test results of all autotests, related to found work item   System sort results by CompletedOn ascending, then by CreatedDate ascending   System returns sorted collection of test results
     * @param id 
     * @return ApiResponse<kotlin.collections.List<TestResultChronologyModel>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getWorkItemChronologyWithHttpInfo(id: kotlin.String) : ApiResponse<kotlin.collections.List<TestResultChronologyModel>?> {
        val localVariableConfig = getWorkItemChronologyRequestConfig(id = id)

        return request<Unit, kotlin.collections.List<TestResultChronologyModel>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getWorkItemChronology
     *
     * @param id 
     * @return RequestConfig
     */
    fun getWorkItemChronologyRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/workItems/{id}/chronology".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get WorkItem versions
     *  Use case   User sets work item identifier   [Optional] User sets work item version identifier   User runs method execution   System search work item by identifier                         [Optional] If User set work item version identifier, System search work item version by version identifier                      Otherwise, system search all version of work item                     System returns array of work item version models (listed in response example)
     * @param id WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @param workItemVersionId WorkItem version (guid format)  identifier\&quot; (optional)
     * @param versionNumber WorkItem version (integer format)  number\&quot; (optional)
     * @return kotlin.collections.List<WorkItemVersionModel>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getWorkItemVersions(id: kotlin.String, workItemVersionId: java.util.UUID? = null, versionNumber: kotlin.Int? = null) : kotlin.collections.List<WorkItemVersionModel> {
        val localVarResponse = getWorkItemVersionsWithHttpInfo(id = id, workItemVersionId = workItemVersionId, versionNumber = versionNumber)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<WorkItemVersionModel>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get WorkItem versions
     *  Use case   User sets work item identifier   [Optional] User sets work item version identifier   User runs method execution   System search work item by identifier                         [Optional] If User set work item version identifier, System search work item version by version identifier                      Otherwise, system search all version of work item                     System returns array of work item version models (listed in response example)
     * @param id WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @param workItemVersionId WorkItem version (guid format)  identifier\&quot; (optional)
     * @param versionNumber WorkItem version (integer format)  number\&quot; (optional)
     * @return ApiResponse<kotlin.collections.List<WorkItemVersionModel>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getWorkItemVersionsWithHttpInfo(id: kotlin.String, workItemVersionId: java.util.UUID?, versionNumber: kotlin.Int?) : ApiResponse<kotlin.collections.List<WorkItemVersionModel>?> {
        val localVariableConfig = getWorkItemVersionsRequestConfig(id = id, workItemVersionId = workItemVersionId, versionNumber = versionNumber)

        return request<Unit, kotlin.collections.List<WorkItemVersionModel>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getWorkItemVersions
     *
     * @param id WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @param workItemVersionId WorkItem version (guid format)  identifier\&quot; (optional)
     * @param versionNumber WorkItem version (integer format)  number\&quot; (optional)
     * @return RequestConfig
     */
    fun getWorkItemVersionsRequestConfig(id: kotlin.String, workItemVersionId: java.util.UUID?, versionNumber: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (workItemVersionId != null) {
                    put("workItemVersionId", listOf(workItemVersionId.toString()))
                }
                if (versionNumber != null) {
                    put("versionNumber", listOf(versionNumber.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/workItems/{id}/versions".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Permanently delete test case, checklist or shared steps from archive
     * 
     * @param id Unique or global ID of the work item
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun purgeWorkItem(id: kotlin.String) : Unit {
        val localVarResponse = purgeWorkItemWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Permanently delete test case, checklist or shared steps from archive
     * 
     * @param id Unique or global ID of the work item
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun purgeWorkItemWithHttpInfo(id: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = purgeWorkItemRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation purgeWorkItem
     *
     * @param id Unique or global ID of the work item
     * @return RequestConfig
     */
    fun purgeWorkItemRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/workItems/{id}/purge".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Restore test case, checklist or shared steps from archive
     * 
     * @param id Unique or global ID of the work item
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun restoreWorkItem(id: kotlin.String) : Unit {
        val localVarResponse = restoreWorkItemWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Restore test case, checklist or shared steps from archive
     * 
     * @param id Unique or global ID of the work item
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun restoreWorkItemWithHttpInfo(id: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = restoreWorkItemRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation restoreWorkItem
     *
     * @param id Unique or global ID of the work item
     * @return RequestConfig
     */
    fun restoreWorkItemRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/workItems/{id}/restore".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Update Test Case, Checklist or Shared Step
     *  Use case   User sets work item properties (listed in request parameters)   User runs method execution   System updates work item by identifier   System returns updated work item model (listed in response parameters)
     * @param workItemPutModel  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateWorkItem(workItemPutModel: WorkItemPutModel? = null) : Unit {
        val localVarResponse = updateWorkItemWithHttpInfo(workItemPutModel = workItemPutModel)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update Test Case, Checklist or Shared Step
     *  Use case   User sets work item properties (listed in request parameters)   User runs method execution   System updates work item by identifier   System returns updated work item model (listed in response parameters)
     * @param workItemPutModel  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun updateWorkItemWithHttpInfo(workItemPutModel: WorkItemPutModel?) : ApiResponse<Unit?> {
        val localVariableConfig = updateWorkItemRequestConfig(workItemPutModel = workItemPutModel)

        return request<WorkItemPutModel, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateWorkItem
     *
     * @param workItemPutModel  (optional)
     * @return RequestConfig
     */
    fun updateWorkItemRequestConfig(workItemPutModel: WorkItemPutModel?) : RequestConfig<WorkItemPutModel> {
        val localVariableBody = workItemPutModel
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v2/workItems",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
