/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package ru.testit.kotlin.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import ru.testit.kotlin.client.models.AutoTestNamespacesCountResponse
import ru.testit.kotlin.client.models.AutoTestResultsForTestRunModel
import ru.testit.kotlin.client.models.CreateEmptyTestRunApiModel
import ru.testit.kotlin.client.models.CreateTestRunAndFillByAutoTestsApiModel
import ru.testit.kotlin.client.models.CreateTestRunAndFillByConfigurationsApiModel
import ru.testit.kotlin.client.models.CreateTestRunAndFillByWorkItemsApiModel
import ru.testit.kotlin.client.models.ManualRerunApiResult
import ru.testit.kotlin.client.models.ManualRerunSelectTestResultsApiModel
import ru.testit.kotlin.client.models.ProblemDetails
import ru.testit.kotlin.client.models.TestPointResultApiResult
import ru.testit.kotlin.client.models.TestResultsStatisticsApiResult
import ru.testit.kotlin.client.models.TestRunFilterApiModel
import ru.testit.kotlin.client.models.TestRunSelectApiModel
import ru.testit.kotlin.client.models.TestRunShortApiResult
import ru.testit.kotlin.client.models.TestRunStatisticsFilterApiModel
import ru.testit.kotlin.client.models.TestRunTestResultsPartialBulkSetModel
import ru.testit.kotlin.client.models.TestRunV2ApiResult
import ru.testit.kotlin.client.models.UpdateEmptyTestRunApiModel
import ru.testit.kotlin.client.models.UpdateMultipleTestRunsApiModel
import ru.testit.kotlin.client.models.ValidationProblemDetails

import com.squareup.moshi.Json

import ru.testit.kotlin.client.infrastructure.ApiClient
import ru.testit.kotlin.client.infrastructure.ApiResponse
import ru.testit.kotlin.client.infrastructure.ClientException
import ru.testit.kotlin.client.infrastructure.ClientError
import ru.testit.kotlin.client.infrastructure.ServerException
import ru.testit.kotlin.client.infrastructure.ServerError
import ru.testit.kotlin.client.infrastructure.MultiValueMap
import ru.testit.kotlin.client.infrastructure.PartConfig
import ru.testit.kotlin.client.infrastructure.RequestConfig
import ru.testit.kotlin.client.infrastructure.RequestMethod
import ru.testit.kotlin.client.infrastructure.ResponseType
import ru.testit.kotlin.client.infrastructure.Success
import ru.testit.kotlin.client.infrastructure.toMultiValue

class TestRunsApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * DELETE /api/v2/testRuns
     * Delete multiple test runs
     *  Use case  User sets selection parameters of test runs  System search and delete collection of test runs  System returns the number of deleted test runs
     * @param testRunSelectApiModel  (optional)
     * @return kotlin.Int
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2TestRunsDelete(testRunSelectApiModel: TestRunSelectApiModel? = null) : kotlin.Int {
        val localVarResponse = apiV2TestRunsDeleteWithHttpInfo(testRunSelectApiModel = testRunSelectApiModel)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Int
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * DELETE /api/v2/testRuns
     * Delete multiple test runs
     *  Use case  User sets selection parameters of test runs  System search and delete collection of test runs  System returns the number of deleted test runs
     * @param testRunSelectApiModel  (optional)
     * @return ApiResponse<kotlin.Int?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2TestRunsDeleteWithHttpInfo(testRunSelectApiModel: TestRunSelectApiModel?) : ApiResponse<kotlin.Int?> {
        val localVariableConfig = apiV2TestRunsDeleteRequestConfig(testRunSelectApiModel = testRunSelectApiModel)

        return request<TestRunSelectApiModel, kotlin.Int>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2TestRunsDelete
     *
     * @param testRunSelectApiModel  (optional)
     * @return RequestConfig
     */
    fun apiV2TestRunsDeleteRequestConfig(testRunSelectApiModel: TestRunSelectApiModel?) : RequestConfig<TestRunSelectApiModel> {
        val localVariableBody = testRunSelectApiModel
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/testRuns",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/v2/testRuns/{id}/autoTestsNamespaces
     * Get autotest classes and namespaces in test run
     * 
     * @param id 
     * @return AutoTestNamespacesCountResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2TestRunsIdAutoTestsNamespacesGet(id: java.util.UUID) : AutoTestNamespacesCountResponse {
        val localVarResponse = apiV2TestRunsIdAutoTestsNamespacesGetWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AutoTestNamespacesCountResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/v2/testRuns/{id}/autoTestsNamespaces
     * Get autotest classes and namespaces in test run
     * 
     * @param id 
     * @return ApiResponse<AutoTestNamespacesCountResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2TestRunsIdAutoTestsNamespacesGetWithHttpInfo(id: java.util.UUID) : ApiResponse<AutoTestNamespacesCountResponse?> {
        val localVariableConfig = apiV2TestRunsIdAutoTestsNamespacesGetRequestConfig(id = id)

        return request<Unit, AutoTestNamespacesCountResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2TestRunsIdAutoTestsNamespacesGet
     *
     * @param id 
     * @return RequestConfig
     */
    fun apiV2TestRunsIdAutoTestsNamespacesGetRequestConfig(id: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/testRuns/{id}/autoTestsNamespaces".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * DELETE /api/v2/testRuns/{id}
     * Delete test run
     *  Use case  User sets test run internal (guid format) identifier  System search and delete test run
     * @param id Test run internal (UUID) identifier
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2TestRunsIdDelete(id: java.util.UUID) : Unit {
        val localVarResponse = apiV2TestRunsIdDeleteWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * DELETE /api/v2/testRuns/{id}
     * Delete test run
     *  Use case  User sets test run internal (guid format) identifier  System search and delete test run
     * @param id Test run internal (UUID) identifier
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2TestRunsIdDeleteWithHttpInfo(id: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = apiV2TestRunsIdDeleteRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2TestRunsIdDelete
     *
     * @param id Test run internal (UUID) identifier
     * @return RequestConfig
     */
    fun apiV2TestRunsIdDeleteRequestConfig(id: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/testRuns/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/v2/testRuns/{id}/purge
     * Permanently delete test run from archive
     *  Use case  User sets archived test run internal (guid format) identifier  System search and purge archived test run
     * @param id Test run internal (UUID) identifier
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2TestRunsIdPurgePost(id: java.util.UUID) : Unit {
        val localVarResponse = apiV2TestRunsIdPurgePostWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/v2/testRuns/{id}/purge
     * Permanently delete test run from archive
     *  Use case  User sets archived test run internal (guid format) identifier  System search and purge archived test run
     * @param id Test run internal (UUID) identifier
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2TestRunsIdPurgePostWithHttpInfo(id: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = apiV2TestRunsIdPurgePostRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2TestRunsIdPurgePost
     *
     * @param id Test run internal (UUID) identifier
     * @return RequestConfig
     */
    fun apiV2TestRunsIdPurgePostRequestConfig(id: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/testRuns/{id}/purge".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/v2/testRuns/{id}/reruns
     * Manual autotests rerun in test run
     * 
     * @param id 
     * @param manualRerunSelectTestResultsApiModel  (optional)
     * @return ManualRerunApiResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2TestRunsIdRerunsPost(id: java.util.UUID, manualRerunSelectTestResultsApiModel: ManualRerunSelectTestResultsApiModel? = null) : ManualRerunApiResult {
        val localVarResponse = apiV2TestRunsIdRerunsPostWithHttpInfo(id = id, manualRerunSelectTestResultsApiModel = manualRerunSelectTestResultsApiModel)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ManualRerunApiResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/v2/testRuns/{id}/reruns
     * Manual autotests rerun in test run
     * 
     * @param id 
     * @param manualRerunSelectTestResultsApiModel  (optional)
     * @return ApiResponse<ManualRerunApiResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2TestRunsIdRerunsPostWithHttpInfo(id: java.util.UUID, manualRerunSelectTestResultsApiModel: ManualRerunSelectTestResultsApiModel?) : ApiResponse<ManualRerunApiResult?> {
        val localVariableConfig = apiV2TestRunsIdRerunsPostRequestConfig(id = id, manualRerunSelectTestResultsApiModel = manualRerunSelectTestResultsApiModel)

        return request<ManualRerunSelectTestResultsApiModel, ManualRerunApiResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2TestRunsIdRerunsPost
     *
     * @param id 
     * @param manualRerunSelectTestResultsApiModel  (optional)
     * @return RequestConfig
     */
    fun apiV2TestRunsIdRerunsPostRequestConfig(id: java.util.UUID, manualRerunSelectTestResultsApiModel: ManualRerunSelectTestResultsApiModel?) : RequestConfig<ManualRerunSelectTestResultsApiModel> {
        val localVariableBody = manualRerunSelectTestResultsApiModel
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/testRuns/{id}/reruns".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/v2/testRuns/{id}/restore
     * Restore test run from the archive
     *  Use case  User sets archived test run internal (guid format) identifier  System search and restore test run
     * @param id Unique ID of the test run
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2TestRunsIdRestorePost(id: java.util.UUID) : Unit {
        val localVarResponse = apiV2TestRunsIdRestorePostWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/v2/testRuns/{id}/restore
     * Restore test run from the archive
     *  Use case  User sets archived test run internal (guid format) identifier  System search and restore test run
     * @param id Unique ID of the test run
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2TestRunsIdRestorePostWithHttpInfo(id: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = apiV2TestRunsIdRestorePostRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2TestRunsIdRestorePost
     *
     * @param id Unique ID of the test run
     * @return RequestConfig
     */
    fun apiV2TestRunsIdRestorePostRequestConfig(id: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/testRuns/{id}/restore".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/v2/testRuns/{id}/statistics/filter
     * Search for the test run test results and build statistics
     * 
     * @param id Test run unique ID
     * @param testRunStatisticsFilterApiModel  (optional)
     * @return TestResultsStatisticsApiResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2TestRunsIdStatisticsFilterPost(id: java.util.UUID, testRunStatisticsFilterApiModel: TestRunStatisticsFilterApiModel? = null) : TestResultsStatisticsApiResult {
        val localVarResponse = apiV2TestRunsIdStatisticsFilterPostWithHttpInfo(id = id, testRunStatisticsFilterApiModel = testRunStatisticsFilterApiModel)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TestResultsStatisticsApiResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/v2/testRuns/{id}/statistics/filter
     * Search for the test run test results and build statistics
     * 
     * @param id Test run unique ID
     * @param testRunStatisticsFilterApiModel  (optional)
     * @return ApiResponse<TestResultsStatisticsApiResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2TestRunsIdStatisticsFilterPostWithHttpInfo(id: java.util.UUID, testRunStatisticsFilterApiModel: TestRunStatisticsFilterApiModel?) : ApiResponse<TestResultsStatisticsApiResult?> {
        val localVariableConfig = apiV2TestRunsIdStatisticsFilterPostRequestConfig(id = id, testRunStatisticsFilterApiModel = testRunStatisticsFilterApiModel)

        return request<TestRunStatisticsFilterApiModel, TestResultsStatisticsApiResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2TestRunsIdStatisticsFilterPost
     *
     * @param id Test run unique ID
     * @param testRunStatisticsFilterApiModel  (optional)
     * @return RequestConfig
     */
    fun apiV2TestRunsIdStatisticsFilterPostRequestConfig(id: java.util.UUID, testRunStatisticsFilterApiModel: TestRunStatisticsFilterApiModel?) : RequestConfig<TestRunStatisticsFilterApiModel> {
        val localVariableBody = testRunStatisticsFilterApiModel
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/testRuns/{id}/statistics/filter".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/v2/testRuns/{id}/testPoints/results
     * Get test results from the test run grouped by test points
     * 
     * @param id Test run unique ID
     * @return kotlin.collections.List<TestPointResultApiResult>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2TestRunsIdTestPointsResultsGet(id: java.util.UUID) : kotlin.collections.List<TestPointResultApiResult> {
        val localVarResponse = apiV2TestRunsIdTestPointsResultsGetWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<TestPointResultApiResult>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/v2/testRuns/{id}/testPoints/results
     * Get test results from the test run grouped by test points
     * 
     * @param id Test run unique ID
     * @return ApiResponse<kotlin.collections.List<TestPointResultApiResult>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2TestRunsIdTestPointsResultsGetWithHttpInfo(id: java.util.UUID) : ApiResponse<kotlin.collections.List<TestPointResultApiResult>?> {
        val localVariableConfig = apiV2TestRunsIdTestPointsResultsGetRequestConfig(id = id)

        return request<Unit, kotlin.collections.List<TestPointResultApiResult>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2TestRunsIdTestPointsResultsGet
     *
     * @param id Test run unique ID
     * @return RequestConfig
     */
    fun apiV2TestRunsIdTestPointsResultsGetRequestConfig(id: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/testRuns/{id}/testPoints/results".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * PUT /api/v2/testRuns/{id}/testResults/bulk
     * Partial edit of multiple test results in the test run
     * 
     * @param id Test run unique ID
     * @param testRunTestResultsPartialBulkSetModel  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2TestRunsIdTestResultsBulkPut(id: java.util.UUID, testRunTestResultsPartialBulkSetModel: TestRunTestResultsPartialBulkSetModel? = null) : Unit {
        val localVarResponse = apiV2TestRunsIdTestResultsBulkPutWithHttpInfo(id = id, testRunTestResultsPartialBulkSetModel = testRunTestResultsPartialBulkSetModel)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * PUT /api/v2/testRuns/{id}/testResults/bulk
     * Partial edit of multiple test results in the test run
     * 
     * @param id Test run unique ID
     * @param testRunTestResultsPartialBulkSetModel  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2TestRunsIdTestResultsBulkPutWithHttpInfo(id: java.util.UUID, testRunTestResultsPartialBulkSetModel: TestRunTestResultsPartialBulkSetModel?) : ApiResponse<Unit?> {
        val localVariableConfig = apiV2TestRunsIdTestResultsBulkPutRequestConfig(id = id, testRunTestResultsPartialBulkSetModel = testRunTestResultsPartialBulkSetModel)

        return request<TestRunTestResultsPartialBulkSetModel, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2TestRunsIdTestResultsBulkPut
     *
     * @param id Test run unique ID
     * @param testRunTestResultsPartialBulkSetModel  (optional)
     * @return RequestConfig
     */
    fun apiV2TestRunsIdTestResultsBulkPutRequestConfig(id: java.util.UUID, testRunTestResultsPartialBulkSetModel: TestRunTestResultsPartialBulkSetModel?) : RequestConfig<TestRunTestResultsPartialBulkSetModel> {
        val localVariableBody = testRunTestResultsPartialBulkSetModel
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v2/testRuns/{id}/testResults/bulk".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/v2/testRuns/{id}/testResults/lastModified/modificationDate
     * Get modification date of last test result of the test run
     * 
     * @param id Test run unique ID
     * @return java.time.OffsetDateTime
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2TestRunsIdTestResultsLastModifiedModificationDateGet(id: java.util.UUID) : java.time.OffsetDateTime {
        val localVarResponse = apiV2TestRunsIdTestResultsLastModifiedModificationDateGetWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as java.time.OffsetDateTime
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/v2/testRuns/{id}/testResults/lastModified/modificationDate
     * Get modification date of last test result of the test run
     * 
     * @param id Test run unique ID
     * @return ApiResponse<java.time.OffsetDateTime?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2TestRunsIdTestResultsLastModifiedModificationDateGetWithHttpInfo(id: java.util.UUID) : ApiResponse<java.time.OffsetDateTime?> {
        val localVariableConfig = apiV2TestRunsIdTestResultsLastModifiedModificationDateGetRequestConfig(id = id)

        return request<Unit, java.time.OffsetDateTime>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2TestRunsIdTestResultsLastModifiedModificationDateGet
     *
     * @param id Test run unique ID
     * @return RequestConfig
     */
    fun apiV2TestRunsIdTestResultsLastModifiedModificationDateGetRequestConfig(id: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/testRuns/{id}/testResults/lastModified/modificationDate".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/v2/testRuns/purge/bulk
     * Permanently delete multiple test runs from archive
     *  Use case  User sets selection parameters of archived test runs  System search and delete collection of archived test runs  System returns the number of deleted archived test runs
     * @param testRunSelectApiModel  (optional)
     * @return kotlin.Int
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2TestRunsPurgeBulkPost(testRunSelectApiModel: TestRunSelectApiModel? = null) : kotlin.Int {
        val localVarResponse = apiV2TestRunsPurgeBulkPostWithHttpInfo(testRunSelectApiModel = testRunSelectApiModel)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Int
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/v2/testRuns/purge/bulk
     * Permanently delete multiple test runs from archive
     *  Use case  User sets selection parameters of archived test runs  System search and delete collection of archived test runs  System returns the number of deleted archived test runs
     * @param testRunSelectApiModel  (optional)
     * @return ApiResponse<kotlin.Int?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2TestRunsPurgeBulkPostWithHttpInfo(testRunSelectApiModel: TestRunSelectApiModel?) : ApiResponse<kotlin.Int?> {
        val localVariableConfig = apiV2TestRunsPurgeBulkPostRequestConfig(testRunSelectApiModel = testRunSelectApiModel)

        return request<TestRunSelectApiModel, kotlin.Int>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2TestRunsPurgeBulkPost
     *
     * @param testRunSelectApiModel  (optional)
     * @return RequestConfig
     */
    fun apiV2TestRunsPurgeBulkPostRequestConfig(testRunSelectApiModel: TestRunSelectApiModel?) : RequestConfig<TestRunSelectApiModel> {
        val localVariableBody = testRunSelectApiModel
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/testRuns/purge/bulk",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/v2/testRuns/restore/bulk
     * Restore multiple test runs from the archive
     *  Use case  User sets selection parameters of archived test runs  System search and restore collection of archived test runs  System returns the number of restored test runs
     * @param testRunSelectApiModel  (optional)
     * @return kotlin.Int
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2TestRunsRestoreBulkPost(testRunSelectApiModel: TestRunSelectApiModel? = null) : kotlin.Int {
        val localVarResponse = apiV2TestRunsRestoreBulkPostWithHttpInfo(testRunSelectApiModel = testRunSelectApiModel)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Int
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/v2/testRuns/restore/bulk
     * Restore multiple test runs from the archive
     *  Use case  User sets selection parameters of archived test runs  System search and restore collection of archived test runs  System returns the number of restored test runs
     * @param testRunSelectApiModel  (optional)
     * @return ApiResponse<kotlin.Int?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2TestRunsRestoreBulkPostWithHttpInfo(testRunSelectApiModel: TestRunSelectApiModel?) : ApiResponse<kotlin.Int?> {
        val localVariableConfig = apiV2TestRunsRestoreBulkPostRequestConfig(testRunSelectApiModel = testRunSelectApiModel)

        return request<TestRunSelectApiModel, kotlin.Int>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2TestRunsRestoreBulkPost
     *
     * @param testRunSelectApiModel  (optional)
     * @return RequestConfig
     */
    fun apiV2TestRunsRestoreBulkPostRequestConfig(testRunSelectApiModel: TestRunSelectApiModel?) : RequestConfig<TestRunSelectApiModel> {
        val localVariableBody = testRunSelectApiModel
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/testRuns/restore/bulk",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/v2/testRuns/search
     * Search for test runs
     * 
     * @param skip Amount of items to be skipped (offset) (optional)
     * @param take Amount of items to be taken (limit) (optional)
     * @param orderBy SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC) (optional)
     * @param searchField Property name for searching (optional)
     * @param searchValue Value for searching (optional)
     * @param testRunFilterApiModel  (optional)
     * @return kotlin.collections.List<TestRunShortApiResult>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2TestRunsSearchPost(skip: kotlin.Int? = null, take: kotlin.Int? = null, orderBy: kotlin.String? = null, searchField: kotlin.String? = null, searchValue: kotlin.String? = null, testRunFilterApiModel: TestRunFilterApiModel? = null) : kotlin.collections.List<TestRunShortApiResult> {
        val localVarResponse = apiV2TestRunsSearchPostWithHttpInfo(skip = skip, take = take, orderBy = orderBy, searchField = searchField, searchValue = searchValue, testRunFilterApiModel = testRunFilterApiModel)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<TestRunShortApiResult>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/v2/testRuns/search
     * Search for test runs
     * 
     * @param skip Amount of items to be skipped (offset) (optional)
     * @param take Amount of items to be taken (limit) (optional)
     * @param orderBy SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC) (optional)
     * @param searchField Property name for searching (optional)
     * @param searchValue Value for searching (optional)
     * @param testRunFilterApiModel  (optional)
     * @return ApiResponse<kotlin.collections.List<TestRunShortApiResult>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2TestRunsSearchPostWithHttpInfo(skip: kotlin.Int?, take: kotlin.Int?, orderBy: kotlin.String?, searchField: kotlin.String?, searchValue: kotlin.String?, testRunFilterApiModel: TestRunFilterApiModel?) : ApiResponse<kotlin.collections.List<TestRunShortApiResult>?> {
        val localVariableConfig = apiV2TestRunsSearchPostRequestConfig(skip = skip, take = take, orderBy = orderBy, searchField = searchField, searchValue = searchValue, testRunFilterApiModel = testRunFilterApiModel)

        return request<TestRunFilterApiModel, kotlin.collections.List<TestRunShortApiResult>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2TestRunsSearchPost
     *
     * @param skip Amount of items to be skipped (offset) (optional)
     * @param take Amount of items to be taken (limit) (optional)
     * @param orderBy SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC) (optional)
     * @param searchField Property name for searching (optional)
     * @param searchValue Value for searching (optional)
     * @param testRunFilterApiModel  (optional)
     * @return RequestConfig
     */
    fun apiV2TestRunsSearchPostRequestConfig(skip: kotlin.Int?, take: kotlin.Int?, orderBy: kotlin.String?, searchField: kotlin.String?, searchValue: kotlin.String?, testRunFilterApiModel: TestRunFilterApiModel?) : RequestConfig<TestRunFilterApiModel> {
        val localVariableBody = testRunFilterApiModel
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (skip != null) {
                    put("Skip", listOf(skip.toString()))
                }
                if (take != null) {
                    put("Take", listOf(take.toString()))
                }
                if (orderBy != null) {
                    put("OrderBy", listOf(orderBy.toString()))
                }
                if (searchField != null) {
                    put("SearchField", listOf(searchField.toString()))
                }
                if (searchValue != null) {
                    put("SearchValue", listOf(searchValue.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/testRuns/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/v2/testRuns/updateMultiple
     * Update multiple test runs
     * 
     * @param updateMultipleTestRunsApiModel  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2TestRunsUpdateMultiplePost(updateMultipleTestRunsApiModel: UpdateMultipleTestRunsApiModel? = null) : Unit {
        val localVarResponse = apiV2TestRunsUpdateMultiplePostWithHttpInfo(updateMultipleTestRunsApiModel = updateMultipleTestRunsApiModel)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/v2/testRuns/updateMultiple
     * Update multiple test runs
     * 
     * @param updateMultipleTestRunsApiModel  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2TestRunsUpdateMultiplePostWithHttpInfo(updateMultipleTestRunsApiModel: UpdateMultipleTestRunsApiModel?) : ApiResponse<Unit?> {
        val localVariableConfig = apiV2TestRunsUpdateMultiplePostRequestConfig(updateMultipleTestRunsApiModel = updateMultipleTestRunsApiModel)

        return request<UpdateMultipleTestRunsApiModel, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2TestRunsUpdateMultiplePost
     *
     * @param updateMultipleTestRunsApiModel  (optional)
     * @return RequestConfig
     */
    fun apiV2TestRunsUpdateMultiplePostRequestConfig(updateMultipleTestRunsApiModel: UpdateMultipleTestRunsApiModel?) : RequestConfig<UpdateMultipleTestRunsApiModel> {
        val localVariableBody = updateMultipleTestRunsApiModel
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/testRuns/updateMultiple",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/v2/testRuns/{id}/complete
     * Complete TestRun
     *  Use case  User sets test run identifier  User runs method execution  System completes test run  System returns no content response
     * @param id Test Run internal identifier (GUID format)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun completeTestRun(id: java.util.UUID) : Unit {
        val localVarResponse = completeTestRunWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/v2/testRuns/{id}/complete
     * Complete TestRun
     *  Use case  User sets test run identifier  User runs method execution  System completes test run  System returns no content response
     * @param id Test Run internal identifier (GUID format)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun completeTestRunWithHttpInfo(id: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = completeTestRunRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation completeTestRun
     *
     * @param id Test Run internal identifier (GUID format)
     * @return RequestConfig
     */
    fun completeTestRunRequestConfig(id: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/testRuns/{id}/complete".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/v2/testRuns/byAutoTests
     * Create test runs based on autotests and configurations
     * This method creates a test run based on an autotest and a configuration. The difference between the &#x60;POST /api/v2/testRuns/byWorkItems&#x60; and &#x60;POST /api/v2/testRuns/byConfigurations&#x60; methods is that in this method there is no need to create a test plan and work items (test cases and checklists).
     * @param createTestRunAndFillByAutoTestsApiModel  (optional)
     * @return TestRunV2ApiResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createAndFillByAutoTests(createTestRunAndFillByAutoTestsApiModel: CreateTestRunAndFillByAutoTestsApiModel? = null) : TestRunV2ApiResult {
        val localVarResponse = createAndFillByAutoTestsWithHttpInfo(createTestRunAndFillByAutoTestsApiModel = createTestRunAndFillByAutoTestsApiModel)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TestRunV2ApiResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/v2/testRuns/byAutoTests
     * Create test runs based on autotests and configurations
     * This method creates a test run based on an autotest and a configuration. The difference between the &#x60;POST /api/v2/testRuns/byWorkItems&#x60; and &#x60;POST /api/v2/testRuns/byConfigurations&#x60; methods is that in this method there is no need to create a test plan and work items (test cases and checklists).
     * @param createTestRunAndFillByAutoTestsApiModel  (optional)
     * @return ApiResponse<TestRunV2ApiResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createAndFillByAutoTestsWithHttpInfo(createTestRunAndFillByAutoTestsApiModel: CreateTestRunAndFillByAutoTestsApiModel?) : ApiResponse<TestRunV2ApiResult?> {
        val localVariableConfig = createAndFillByAutoTestsRequestConfig(createTestRunAndFillByAutoTestsApiModel = createTestRunAndFillByAutoTestsApiModel)

        return request<CreateTestRunAndFillByAutoTestsApiModel, TestRunV2ApiResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createAndFillByAutoTests
     *
     * @param createTestRunAndFillByAutoTestsApiModel  (optional)
     * @return RequestConfig
     */
    fun createAndFillByAutoTestsRequestConfig(createTestRunAndFillByAutoTestsApiModel: CreateTestRunAndFillByAutoTestsApiModel?) : RequestConfig<CreateTestRunAndFillByAutoTestsApiModel> {
        val localVariableBody = createTestRunAndFillByAutoTestsApiModel
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/testRuns/byAutoTests",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/v2/testRuns/byConfigurations
     * Create test runs picking the needed test points
     * This method creates a test run based on a combination of a configuration and a work item(test case or checklist). Before you create a test run using this method, make sure to create a test plan. Work items must be automated. This method is different from the &#x60;POST /api/v2/testRuns/byWorkItems&#x60; method because of the ability to send a jagged array within the \&quot;&lt;b&gt;testPointSelectors&lt;/b&gt;\&quot; parameter.
     * @param createTestRunAndFillByConfigurationsApiModel  (optional)
     * @return TestRunV2ApiResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createAndFillByConfigurations(createTestRunAndFillByConfigurationsApiModel: CreateTestRunAndFillByConfigurationsApiModel? = null) : TestRunV2ApiResult {
        val localVarResponse = createAndFillByConfigurationsWithHttpInfo(createTestRunAndFillByConfigurationsApiModel = createTestRunAndFillByConfigurationsApiModel)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TestRunV2ApiResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/v2/testRuns/byConfigurations
     * Create test runs picking the needed test points
     * This method creates a test run based on a combination of a configuration and a work item(test case or checklist). Before you create a test run using this method, make sure to create a test plan. Work items must be automated. This method is different from the &#x60;POST /api/v2/testRuns/byWorkItems&#x60; method because of the ability to send a jagged array within the \&quot;&lt;b&gt;testPointSelectors&lt;/b&gt;\&quot; parameter.
     * @param createTestRunAndFillByConfigurationsApiModel  (optional)
     * @return ApiResponse<TestRunV2ApiResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createAndFillByConfigurationsWithHttpInfo(createTestRunAndFillByConfigurationsApiModel: CreateTestRunAndFillByConfigurationsApiModel?) : ApiResponse<TestRunV2ApiResult?> {
        val localVariableConfig = createAndFillByConfigurationsRequestConfig(createTestRunAndFillByConfigurationsApiModel = createTestRunAndFillByConfigurationsApiModel)

        return request<CreateTestRunAndFillByConfigurationsApiModel, TestRunV2ApiResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createAndFillByConfigurations
     *
     * @param createTestRunAndFillByConfigurationsApiModel  (optional)
     * @return RequestConfig
     */
    fun createAndFillByConfigurationsRequestConfig(createTestRunAndFillByConfigurationsApiModel: CreateTestRunAndFillByConfigurationsApiModel?) : RequestConfig<CreateTestRunAndFillByConfigurationsApiModel> {
        val localVariableBody = createTestRunAndFillByConfigurationsApiModel
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/testRuns/byConfigurations",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/v2/testRuns/byWorkItems
     * Create test run based on configurations and work items
     * This method creates a test run based on a combination of configuration and work item (test case or checklist). Before you create a test run using this method, make sure to create a test plan. Work items must be automated.
     * @param createTestRunAndFillByWorkItemsApiModel  (optional)
     * @return TestRunV2ApiResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createAndFillByWorkItems(createTestRunAndFillByWorkItemsApiModel: CreateTestRunAndFillByWorkItemsApiModel? = null) : TestRunV2ApiResult {
        val localVarResponse = createAndFillByWorkItemsWithHttpInfo(createTestRunAndFillByWorkItemsApiModel = createTestRunAndFillByWorkItemsApiModel)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TestRunV2ApiResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/v2/testRuns/byWorkItems
     * Create test run based on configurations and work items
     * This method creates a test run based on a combination of configuration and work item (test case or checklist). Before you create a test run using this method, make sure to create a test plan. Work items must be automated.
     * @param createTestRunAndFillByWorkItemsApiModel  (optional)
     * @return ApiResponse<TestRunV2ApiResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createAndFillByWorkItemsWithHttpInfo(createTestRunAndFillByWorkItemsApiModel: CreateTestRunAndFillByWorkItemsApiModel?) : ApiResponse<TestRunV2ApiResult?> {
        val localVariableConfig = createAndFillByWorkItemsRequestConfig(createTestRunAndFillByWorkItemsApiModel = createTestRunAndFillByWorkItemsApiModel)

        return request<CreateTestRunAndFillByWorkItemsApiModel, TestRunV2ApiResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createAndFillByWorkItems
     *
     * @param createTestRunAndFillByWorkItemsApiModel  (optional)
     * @return RequestConfig
     */
    fun createAndFillByWorkItemsRequestConfig(createTestRunAndFillByWorkItemsApiModel: CreateTestRunAndFillByWorkItemsApiModel?) : RequestConfig<CreateTestRunAndFillByWorkItemsApiModel> {
        val localVariableBody = createTestRunAndFillByWorkItemsApiModel
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/testRuns/byWorkItems",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/v2/testRuns
     * Create empty TestRun
     *  Use case  User sets test run model (listed in the request example)  User runs method execution  System creates test run  System returns test run model
     * @param createEmptyTestRunApiModel  (optional)
     * @return TestRunV2ApiResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createEmpty(createEmptyTestRunApiModel: CreateEmptyTestRunApiModel? = null) : TestRunV2ApiResult {
        val localVarResponse = createEmptyWithHttpInfo(createEmptyTestRunApiModel = createEmptyTestRunApiModel)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TestRunV2ApiResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/v2/testRuns
     * Create empty TestRun
     *  Use case  User sets test run model (listed in the request example)  User runs method execution  System creates test run  System returns test run model
     * @param createEmptyTestRunApiModel  (optional)
     * @return ApiResponse<TestRunV2ApiResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createEmptyWithHttpInfo(createEmptyTestRunApiModel: CreateEmptyTestRunApiModel?) : ApiResponse<TestRunV2ApiResult?> {
        val localVariableConfig = createEmptyRequestConfig(createEmptyTestRunApiModel = createEmptyTestRunApiModel)

        return request<CreateEmptyTestRunApiModel, TestRunV2ApiResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createEmpty
     *
     * @param createEmptyTestRunApiModel  (optional)
     * @return RequestConfig
     */
    fun createEmptyRequestConfig(createEmptyTestRunApiModel: CreateEmptyTestRunApiModel?) : RequestConfig<CreateEmptyTestRunApiModel> {
        val localVariableBody = createEmptyTestRunApiModel
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/testRuns",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/v2/testRuns/{id}
     * Get TestRun by Id
     *  Use case  User sets test run identifier  User runs method execution  System finds test run  System returns test run
     * @param id Test Run internal identifier (GUID format)
     * @return TestRunV2ApiResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getTestRunById(id: java.util.UUID) : TestRunV2ApiResult {
        val localVarResponse = getTestRunByIdWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TestRunV2ApiResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/v2/testRuns/{id}
     * Get TestRun by Id
     *  Use case  User sets test run identifier  User runs method execution  System finds test run  System returns test run
     * @param id Test Run internal identifier (GUID format)
     * @return ApiResponse<TestRunV2ApiResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getTestRunByIdWithHttpInfo(id: java.util.UUID) : ApiResponse<TestRunV2ApiResult?> {
        val localVariableConfig = getTestRunByIdRequestConfig(id = id)

        return request<Unit, TestRunV2ApiResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getTestRunById
     *
     * @param id Test Run internal identifier (GUID format)
     * @return RequestConfig
     */
    fun getTestRunByIdRequestConfig(id: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/testRuns/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/v2/testRuns/{id}/testResults
     * Send test results to the test runs in the system
     * This method sends test results to the test management system.
     * @param id Test Run internal identifier (GUID format)
     * @param autoTestResultsForTestRunModel  (optional)
     * @return kotlin.collections.List<java.util.UUID>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun setAutoTestResultsForTestRun(id: java.util.UUID, autoTestResultsForTestRunModel: kotlin.collections.List<AutoTestResultsForTestRunModel>? = null) : kotlin.collections.List<java.util.UUID> {
        val localVarResponse = setAutoTestResultsForTestRunWithHttpInfo(id = id, autoTestResultsForTestRunModel = autoTestResultsForTestRunModel)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<java.util.UUID>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/v2/testRuns/{id}/testResults
     * Send test results to the test runs in the system
     * This method sends test results to the test management system.
     * @param id Test Run internal identifier (GUID format)
     * @param autoTestResultsForTestRunModel  (optional)
     * @return ApiResponse<kotlin.collections.List<java.util.UUID>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun setAutoTestResultsForTestRunWithHttpInfo(id: java.util.UUID, autoTestResultsForTestRunModel: kotlin.collections.List<AutoTestResultsForTestRunModel>?) : ApiResponse<kotlin.collections.List<java.util.UUID>?> {
        val localVariableConfig = setAutoTestResultsForTestRunRequestConfig(id = id, autoTestResultsForTestRunModel = autoTestResultsForTestRunModel)

        return request<kotlin.collections.List<AutoTestResultsForTestRunModel>, kotlin.collections.List<java.util.UUID>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation setAutoTestResultsForTestRun
     *
     * @param id Test Run internal identifier (GUID format)
     * @param autoTestResultsForTestRunModel  (optional)
     * @return RequestConfig
     */
    fun setAutoTestResultsForTestRunRequestConfig(id: java.util.UUID, autoTestResultsForTestRunModel: kotlin.collections.List<AutoTestResultsForTestRunModel>?) : RequestConfig<kotlin.collections.List<AutoTestResultsForTestRunModel>> {
        val localVariableBody = autoTestResultsForTestRunModel
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/testRuns/{id}/testResults".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/v2/testRuns/{id}/start
     * Start TestRun
     *  Use case  User sets test run identifier  User runs method execution  System starts test run  System returns no content response
     * @param id Test Run internal identifier (GUID format)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun startTestRun(id: java.util.UUID) : Unit {
        val localVarResponse = startTestRunWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/v2/testRuns/{id}/start
     * Start TestRun
     *  Use case  User sets test run identifier  User runs method execution  System starts test run  System returns no content response
     * @param id Test Run internal identifier (GUID format)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun startTestRunWithHttpInfo(id: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = startTestRunRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation startTestRun
     *
     * @param id Test Run internal identifier (GUID format)
     * @return RequestConfig
     */
    fun startTestRunRequestConfig(id: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/testRuns/{id}/start".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/v2/testRuns/{id}/stop
     * Stop TestRun
     *  Use case  User sets test run identifier  User runs method execution  System stops test run  System returns no content response
     * @param id Test Run internal identifier (GUID format)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stopTestRun(id: java.util.UUID) : Unit {
        val localVarResponse = stopTestRunWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/v2/testRuns/{id}/stop
     * Stop TestRun
     *  Use case  User sets test run identifier  User runs method execution  System stops test run  System returns no content response
     * @param id Test Run internal identifier (GUID format)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun stopTestRunWithHttpInfo(id: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = stopTestRunRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stopTestRun
     *
     * @param id Test Run internal identifier (GUID format)
     * @return RequestConfig
     */
    fun stopTestRunRequestConfig(id: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/testRuns/{id}/stop".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * PUT /api/v2/testRuns
     * Update empty TestRun
     *  Use case  User sets test run properties (listed in the request example)  User runs method execution  System updates test run  System returns returns no content response
     * @param updateEmptyTestRunApiModel  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateEmpty(updateEmptyTestRunApiModel: UpdateEmptyTestRunApiModel? = null) : Unit {
        val localVarResponse = updateEmptyWithHttpInfo(updateEmptyTestRunApiModel = updateEmptyTestRunApiModel)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * PUT /api/v2/testRuns
     * Update empty TestRun
     *  Use case  User sets test run properties (listed in the request example)  User runs method execution  System updates test run  System returns returns no content response
     * @param updateEmptyTestRunApiModel  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun updateEmptyWithHttpInfo(updateEmptyTestRunApiModel: UpdateEmptyTestRunApiModel?) : ApiResponse<Unit?> {
        val localVariableConfig = updateEmptyRequestConfig(updateEmptyTestRunApiModel = updateEmptyTestRunApiModel)

        return request<UpdateEmptyTestRunApiModel, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateEmpty
     *
     * @param updateEmptyTestRunApiModel  (optional)
     * @return RequestConfig
     */
    fun updateEmptyRequestConfig(updateEmptyTestRunApiModel: UpdateEmptyTestRunApiModel?) : RequestConfig<UpdateEmptyTestRunApiModel> {
        val localVariableBody = updateEmptyTestRunApiModel
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v2/testRuns",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
