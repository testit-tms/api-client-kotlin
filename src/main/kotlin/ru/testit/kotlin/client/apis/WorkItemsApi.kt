/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package ru.testit.kotlin.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import ru.testit.kotlin.client.models.AutoTestModel
import ru.testit.kotlin.client.models.CreateWorkItemApiModel
import ru.testit.kotlin.client.models.IterationModel
import ru.testit.kotlin.client.models.ProblemDetails
import ru.testit.kotlin.client.models.SearchWorkItemLinkUrlsApiResult
import ru.testit.kotlin.client.models.SharedStepReferenceModel
import ru.testit.kotlin.client.models.SharedStepReferenceSectionModel
import ru.testit.kotlin.client.models.SharedStepReferenceSectionsQueryFilterModel
import ru.testit.kotlin.client.models.SharedStepReferencesQueryFilterModel
import ru.testit.kotlin.client.models.TestResultChronologyModel
import ru.testit.kotlin.client.models.TestResultHistoryReportApiResult
import ru.testit.kotlin.client.models.UpdateWorkItemApiModel
import ru.testit.kotlin.client.models.ValidationProblemDetails
import ru.testit.kotlin.client.models.WorkItemApiResult
import ru.testit.kotlin.client.models.WorkItemChangeModel
import ru.testit.kotlin.client.models.WorkItemLikeModel
import ru.testit.kotlin.client.models.WorkItemLinkUrlApiModel
import ru.testit.kotlin.client.models.WorkItemModel
import ru.testit.kotlin.client.models.WorkItemMovePostModel
import ru.testit.kotlin.client.models.WorkItemSelectApiModel
import ru.testit.kotlin.client.models.WorkItemShortApiResult
import ru.testit.kotlin.client.models.WorkItemShortModel
import ru.testit.kotlin.client.models.WorkItemVersionModel

import com.squareup.moshi.Json

import ru.testit.kotlin.client.infrastructure.ApiClient
import ru.testit.kotlin.client.infrastructure.ApiResponse
import ru.testit.kotlin.client.infrastructure.ClientException
import ru.testit.kotlin.client.infrastructure.ClientError
import ru.testit.kotlin.client.infrastructure.ServerException
import ru.testit.kotlin.client.infrastructure.ServerError
import ru.testit.kotlin.client.infrastructure.MultiValueMap
import ru.testit.kotlin.client.infrastructure.PartConfig
import ru.testit.kotlin.client.infrastructure.RequestConfig
import ru.testit.kotlin.client.infrastructure.RequestMethod
import ru.testit.kotlin.client.infrastructure.ResponseType
import ru.testit.kotlin.client.infrastructure.Success
import ru.testit.kotlin.client.infrastructure.toMultiValue

class WorkItemsApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * POST /api/v2/workItems/{id}/attachments
     * Upload and link attachment to WorkItem
     *   Use case    User sets workItemId    User attaches a file    System creates attachment and links it to the work item    System returns attachment identifier
     * @param id Work item internal identifier (guid format)
     * @param file Select file (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2WorkItemsIdAttachmentsPost(id: java.util.UUID, file: java.io.File? = null) : Unit {
        val localVarResponse = apiV2WorkItemsIdAttachmentsPostWithHttpInfo(id = id, file = file)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/v2/workItems/{id}/attachments
     * Upload and link attachment to WorkItem
     *   Use case    User sets workItemId    User attaches a file    System creates attachment and links it to the work item    System returns attachment identifier
     * @param id Work item internal identifier (guid format)
     * @param file Select file (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2WorkItemsIdAttachmentsPostWithHttpInfo(id: java.util.UUID, file: java.io.File?) : ApiResponse<Unit?> {
        val localVariableConfig = apiV2WorkItemsIdAttachmentsPostRequestConfig(id = id, file = file)

        return request<Map<String, PartConfig<*>>, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2WorkItemsIdAttachmentsPost
     *
     * @param id Work item internal identifier (guid format)
     * @param file Select file (optional)
     * @return RequestConfig
     */
    fun apiV2WorkItemsIdAttachmentsPostRequestConfig(id: java.util.UUID, file: java.io.File?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "file" to PartConfig(body = file, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/workItems/{id}/attachments".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/v2/workItems/{id}/checkList/transformTo/testCase
     * Transform CheckList to TestCase
     *   Use case    User sets checklist identifier    User runs method execution    System transform CheckList to TestCase
     * @param id 
     * @return WorkItemModel
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2WorkItemsIdCheckListTransformToTestCasePost(id: java.util.UUID) : WorkItemModel {
        val localVarResponse = apiV2WorkItemsIdCheckListTransformToTestCasePostWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as WorkItemModel
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/v2/workItems/{id}/checkList/transformTo/testCase
     * Transform CheckList to TestCase
     *   Use case    User sets checklist identifier    User runs method execution    System transform CheckList to TestCase
     * @param id 
     * @return ApiResponse<WorkItemModel?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2WorkItemsIdCheckListTransformToTestCasePostWithHttpInfo(id: java.util.UUID) : ApiResponse<WorkItemModel?> {
        val localVariableConfig = apiV2WorkItemsIdCheckListTransformToTestCasePostRequestConfig(id = id)

        return request<Unit, WorkItemModel>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2WorkItemsIdCheckListTransformToTestCasePost
     *
     * @param id 
     * @return RequestConfig
     */
    fun apiV2WorkItemsIdCheckListTransformToTestCasePostRequestConfig(id: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/workItems/{id}/checkList/transformTo/testCase".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/v2/workItems/{id}/history
     * Get change history of WorkItem
     *   Use case    User sets work item identifier    User runs method execution    System return change history of WorkItem
     * @param id 
     * @param skip Amount of items to be skipped (offset) (optional)
     * @param take Amount of items to be taken (limit) (optional)
     * @param orderBy SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC) (optional)
     * @param searchField Property name for searching (optional)
     * @param searchValue Value for searching (optional)
     * @return kotlin.collections.List<WorkItemChangeModel>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2WorkItemsIdHistoryGet(id: java.util.UUID, skip: kotlin.Int? = null, take: kotlin.Int? = null, orderBy: kotlin.String? = null, searchField: kotlin.String? = null, searchValue: kotlin.String? = null) : kotlin.collections.List<WorkItemChangeModel> {
        val localVarResponse = apiV2WorkItemsIdHistoryGetWithHttpInfo(id = id, skip = skip, take = take, orderBy = orderBy, searchField = searchField, searchValue = searchValue)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<WorkItemChangeModel>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/v2/workItems/{id}/history
     * Get change history of WorkItem
     *   Use case    User sets work item identifier    User runs method execution    System return change history of WorkItem
     * @param id 
     * @param skip Amount of items to be skipped (offset) (optional)
     * @param take Amount of items to be taken (limit) (optional)
     * @param orderBy SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC) (optional)
     * @param searchField Property name for searching (optional)
     * @param searchValue Value for searching (optional)
     * @return ApiResponse<kotlin.collections.List<WorkItemChangeModel>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2WorkItemsIdHistoryGetWithHttpInfo(id: java.util.UUID, skip: kotlin.Int?, take: kotlin.Int?, orderBy: kotlin.String?, searchField: kotlin.String?, searchValue: kotlin.String?) : ApiResponse<kotlin.collections.List<WorkItemChangeModel>?> {
        val localVariableConfig = apiV2WorkItemsIdHistoryGetRequestConfig(id = id, skip = skip, take = take, orderBy = orderBy, searchField = searchField, searchValue = searchValue)

        return request<Unit, kotlin.collections.List<WorkItemChangeModel>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2WorkItemsIdHistoryGet
     *
     * @param id 
     * @param skip Amount of items to be skipped (offset) (optional)
     * @param take Amount of items to be taken (limit) (optional)
     * @param orderBy SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC) (optional)
     * @param searchField Property name for searching (optional)
     * @param searchValue Value for searching (optional)
     * @return RequestConfig
     */
    fun apiV2WorkItemsIdHistoryGetRequestConfig(id: java.util.UUID, skip: kotlin.Int?, take: kotlin.Int?, orderBy: kotlin.String?, searchField: kotlin.String?, searchValue: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (skip != null) {
                    put("Skip", listOf(skip.toString()))
                }
                if (take != null) {
                    put("Take", listOf(take.toString()))
                }
                if (orderBy != null) {
                    put("OrderBy", listOf(orderBy.toString()))
                }
                if (searchField != null) {
                    put("SearchField", listOf(searchField.toString()))
                }
                if (searchValue != null) {
                    put("SearchValue", listOf(searchValue.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/workItems/{id}/history".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * DELETE /api/v2/workItems/{id}/like
     * Delete like from WorkItem
     *   Use case    User sets WorkItem identifier    User runs method execution    System delete like from WorkItem
     * @param id 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2WorkItemsIdLikeDelete(id: java.util.UUID) : Unit {
        val localVarResponse = apiV2WorkItemsIdLikeDeleteWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * DELETE /api/v2/workItems/{id}/like
     * Delete like from WorkItem
     *   Use case    User sets WorkItem identifier    User runs method execution    System delete like from WorkItem
     * @param id 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2WorkItemsIdLikeDeleteWithHttpInfo(id: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = apiV2WorkItemsIdLikeDeleteRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2WorkItemsIdLikeDelete
     *
     * @param id 
     * @return RequestConfig
     */
    fun apiV2WorkItemsIdLikeDeleteRequestConfig(id: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/workItems/{id}/like".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/v2/workItems/{id}/like
     * Set like to WorkItem
     *   Use case    User sets WorkItem identifier    User runs method execution    System set like to WorkItem
     * @param id 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2WorkItemsIdLikePost(id: java.util.UUID) : Unit {
        val localVarResponse = apiV2WorkItemsIdLikePostWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/v2/workItems/{id}/like
     * Set like to WorkItem
     *   Use case    User sets WorkItem identifier    User runs method execution    System set like to WorkItem
     * @param id 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2WorkItemsIdLikePostWithHttpInfo(id: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = apiV2WorkItemsIdLikePostRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2WorkItemsIdLikePost
     *
     * @param id 
     * @return RequestConfig
     */
    fun apiV2WorkItemsIdLikePostRequestConfig(id: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/workItems/{id}/like".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/v2/workItems/{id}/likes/count
     * Get likes count of WorkItem
     *   Use case    User sets WorkItem identifier    User runs method execution    System return likes count of WorkItem
     * @param id 
     * @return kotlin.Int
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2WorkItemsIdLikesCountGet(id: java.util.UUID) : kotlin.Int {
        val localVarResponse = apiV2WorkItemsIdLikesCountGetWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Int
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/v2/workItems/{id}/likes/count
     * Get likes count of WorkItem
     *   Use case    User sets WorkItem identifier    User runs method execution    System return likes count of WorkItem
     * @param id 
     * @return ApiResponse<kotlin.Int?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2WorkItemsIdLikesCountGetWithHttpInfo(id: java.util.UUID) : ApiResponse<kotlin.Int?> {
        val localVariableConfig = apiV2WorkItemsIdLikesCountGetRequestConfig(id = id)

        return request<Unit, kotlin.Int>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2WorkItemsIdLikesCountGet
     *
     * @param id 
     * @return RequestConfig
     */
    fun apiV2WorkItemsIdLikesCountGetRequestConfig(id: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/workItems/{id}/likes/count".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/v2/workItems/{id}/likes
     * Get likes of WorkItem
     *   Use case    User sets WorkItem identifier    User runs method execution    System return likes of WorkItem
     * @param id 
     * @return kotlin.collections.List<WorkItemLikeModel>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2WorkItemsIdLikesGet(id: java.util.UUID) : kotlin.collections.List<WorkItemLikeModel> {
        val localVarResponse = apiV2WorkItemsIdLikesGetWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<WorkItemLikeModel>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/v2/workItems/{id}/likes
     * Get likes of WorkItem
     *   Use case    User sets WorkItem identifier    User runs method execution    System return likes of WorkItem
     * @param id 
     * @return ApiResponse<kotlin.collections.List<WorkItemLikeModel>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2WorkItemsIdLikesGetWithHttpInfo(id: java.util.UUID) : ApiResponse<kotlin.collections.List<WorkItemLikeModel>?> {
        val localVariableConfig = apiV2WorkItemsIdLikesGetRequestConfig(id = id)

        return request<Unit, kotlin.collections.List<WorkItemLikeModel>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2WorkItemsIdLikesGet
     *
     * @param id 
     * @return RequestConfig
     */
    fun apiV2WorkItemsIdLikesGetRequestConfig(id: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/workItems/{id}/likes".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/v2/workItems/{id}/testResults/history
     * Get test results history of WorkItem
     *   Use case    User sets WorkItem identifier    User runs method execution    System return test results history of WorkItem
     * @param id 
     * @param from Take results from this date (optional)
     * @param to Take results until this date (optional)
     * @param configurationIds Identifiers of test result configurations (optional)
     * @param testPlanIds Identifiers of test plans which contain test results (optional)
     * @param userIds Identifiers of users who set test results (optional)
     * @param outcomes List of outcomes of test results (optional)
     * @param statusCodes List of status codes of test results (optional)
     * @param isAutomated OBSOLETE: Use &#x60;Automated&#x60; instead (optional)
     * @param automated If result must consist of only manual/automated test results (optional)
     * @param testRunIds Identifiers of test runs which contain test results (optional)
     * @param skip Amount of items to be skipped (offset) (optional)
     * @param take Amount of items to be taken (limit) (optional)
     * @param orderBy SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC) (optional)
     * @param searchField Property name for searching (optional)
     * @param searchValue Value for searching (optional)
     * @return kotlin.collections.List<TestResultHistoryReportApiResult>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2WorkItemsIdTestResultsHistoryGet(id: java.util.UUID, from: java.time.OffsetDateTime? = null, to: java.time.OffsetDateTime? = null, configurationIds: kotlin.collections.List<java.util.UUID>? = null, testPlanIds: kotlin.collections.List<java.util.UUID>? = null, userIds: kotlin.collections.List<java.util.UUID>? = null, outcomes: kotlin.collections.List<kotlin.String>? = null, statusCodes: kotlin.collections.List<kotlin.String>? = null, isAutomated: kotlin.Boolean? = null, automated: kotlin.Boolean? = null, testRunIds: kotlin.collections.List<java.util.UUID>? = null, skip: kotlin.Int? = null, take: kotlin.Int? = null, orderBy: kotlin.String? = null, searchField: kotlin.String? = null, searchValue: kotlin.String? = null) : kotlin.collections.List<TestResultHistoryReportApiResult> {
        val localVarResponse = apiV2WorkItemsIdTestResultsHistoryGetWithHttpInfo(id = id, from = from, to = to, configurationIds = configurationIds, testPlanIds = testPlanIds, userIds = userIds, outcomes = outcomes, statusCodes = statusCodes, isAutomated = isAutomated, automated = automated, testRunIds = testRunIds, skip = skip, take = take, orderBy = orderBy, searchField = searchField, searchValue = searchValue)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<TestResultHistoryReportApiResult>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/v2/workItems/{id}/testResults/history
     * Get test results history of WorkItem
     *   Use case    User sets WorkItem identifier    User runs method execution    System return test results history of WorkItem
     * @param id 
     * @param from Take results from this date (optional)
     * @param to Take results until this date (optional)
     * @param configurationIds Identifiers of test result configurations (optional)
     * @param testPlanIds Identifiers of test plans which contain test results (optional)
     * @param userIds Identifiers of users who set test results (optional)
     * @param outcomes List of outcomes of test results (optional)
     * @param statusCodes List of status codes of test results (optional)
     * @param isAutomated OBSOLETE: Use &#x60;Automated&#x60; instead (optional)
     * @param automated If result must consist of only manual/automated test results (optional)
     * @param testRunIds Identifiers of test runs which contain test results (optional)
     * @param skip Amount of items to be skipped (offset) (optional)
     * @param take Amount of items to be taken (limit) (optional)
     * @param orderBy SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC) (optional)
     * @param searchField Property name for searching (optional)
     * @param searchValue Value for searching (optional)
     * @return ApiResponse<kotlin.collections.List<TestResultHistoryReportApiResult>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2WorkItemsIdTestResultsHistoryGetWithHttpInfo(id: java.util.UUID, from: java.time.OffsetDateTime?, to: java.time.OffsetDateTime?, configurationIds: kotlin.collections.List<java.util.UUID>?, testPlanIds: kotlin.collections.List<java.util.UUID>?, userIds: kotlin.collections.List<java.util.UUID>?, outcomes: kotlin.collections.List<kotlin.String>?, statusCodes: kotlin.collections.List<kotlin.String>?, isAutomated: kotlin.Boolean?, automated: kotlin.Boolean?, testRunIds: kotlin.collections.List<java.util.UUID>?, skip: kotlin.Int?, take: kotlin.Int?, orderBy: kotlin.String?, searchField: kotlin.String?, searchValue: kotlin.String?) : ApiResponse<kotlin.collections.List<TestResultHistoryReportApiResult>?> {
        val localVariableConfig = apiV2WorkItemsIdTestResultsHistoryGetRequestConfig(id = id, from = from, to = to, configurationIds = configurationIds, testPlanIds = testPlanIds, userIds = userIds, outcomes = outcomes, statusCodes = statusCodes, isAutomated = isAutomated, automated = automated, testRunIds = testRunIds, skip = skip, take = take, orderBy = orderBy, searchField = searchField, searchValue = searchValue)

        return request<Unit, kotlin.collections.List<TestResultHistoryReportApiResult>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2WorkItemsIdTestResultsHistoryGet
     *
     * @param id 
     * @param from Take results from this date (optional)
     * @param to Take results until this date (optional)
     * @param configurationIds Identifiers of test result configurations (optional)
     * @param testPlanIds Identifiers of test plans which contain test results (optional)
     * @param userIds Identifiers of users who set test results (optional)
     * @param outcomes List of outcomes of test results (optional)
     * @param statusCodes List of status codes of test results (optional)
     * @param isAutomated OBSOLETE: Use &#x60;Automated&#x60; instead (optional)
     * @param automated If result must consist of only manual/automated test results (optional)
     * @param testRunIds Identifiers of test runs which contain test results (optional)
     * @param skip Amount of items to be skipped (offset) (optional)
     * @param take Amount of items to be taken (limit) (optional)
     * @param orderBy SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC) (optional)
     * @param searchField Property name for searching (optional)
     * @param searchValue Value for searching (optional)
     * @return RequestConfig
     */
    fun apiV2WorkItemsIdTestResultsHistoryGetRequestConfig(id: java.util.UUID, from: java.time.OffsetDateTime?, to: java.time.OffsetDateTime?, configurationIds: kotlin.collections.List<java.util.UUID>?, testPlanIds: kotlin.collections.List<java.util.UUID>?, userIds: kotlin.collections.List<java.util.UUID>?, outcomes: kotlin.collections.List<kotlin.String>?, statusCodes: kotlin.collections.List<kotlin.String>?, isAutomated: kotlin.Boolean?, automated: kotlin.Boolean?, testRunIds: kotlin.collections.List<java.util.UUID>?, skip: kotlin.Int?, take: kotlin.Int?, orderBy: kotlin.String?, searchField: kotlin.String?, searchValue: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (from != null) {
                    put("from", listOf(parseDateToQueryString(from)))
                }
                if (to != null) {
                    put("to", listOf(parseDateToQueryString(to)))
                }
                if (configurationIds != null) {
                    put("configurationIds", toMultiValue(configurationIds.toList(), "multi"))
                }
                if (testPlanIds != null) {
                    put("testPlanIds", toMultiValue(testPlanIds.toList(), "multi"))
                }
                if (userIds != null) {
                    put("userIds", toMultiValue(userIds.toList(), "multi"))
                }
                if (outcomes != null) {
                    put("outcomes", toMultiValue(outcomes.toList(), "multi"))
                }
                if (statusCodes != null) {
                    put("statusCodes", toMultiValue(statusCodes.toList(), "multi"))
                }
                if (isAutomated != null) {
                    put("isAutomated", listOf(isAutomated.toString()))
                }
                if (automated != null) {
                    put("automated", listOf(automated.toString()))
                }
                if (testRunIds != null) {
                    put("testRunIds", toMultiValue(testRunIds.toList(), "multi"))
                }
                if (skip != null) {
                    put("Skip", listOf(skip.toString()))
                }
                if (take != null) {
                    put("Take", listOf(take.toString()))
                }
                if (orderBy != null) {
                    put("OrderBy", listOf(orderBy.toString()))
                }
                if (searchField != null) {
                    put("SearchField", listOf(searchField.toString()))
                }
                if (searchValue != null) {
                    put("SearchValue", listOf(searchValue.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/workItems/{id}/testResults/history".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/v2/workItems/{id}/version/{versionId}/actual
     * Set WorkItem as actual
     *   Use case    User sets work item identifier    User runs method execution    System set WorkItem as actual
     * @param id 
     * @param versionId 
     * @return WorkItemModel
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2WorkItemsIdVersionVersionIdActualPost(id: java.util.UUID, versionId: java.util.UUID) : WorkItemModel {
        val localVarResponse = apiV2WorkItemsIdVersionVersionIdActualPostWithHttpInfo(id = id, versionId = versionId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as WorkItemModel
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/v2/workItems/{id}/version/{versionId}/actual
     * Set WorkItem as actual
     *   Use case    User sets work item identifier    User runs method execution    System set WorkItem as actual
     * @param id 
     * @param versionId 
     * @return ApiResponse<WorkItemModel?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2WorkItemsIdVersionVersionIdActualPostWithHttpInfo(id: java.util.UUID, versionId: java.util.UUID) : ApiResponse<WorkItemModel?> {
        val localVariableConfig = apiV2WorkItemsIdVersionVersionIdActualPostRequestConfig(id = id, versionId = versionId)

        return request<Unit, WorkItemModel>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2WorkItemsIdVersionVersionIdActualPost
     *
     * @param id 
     * @param versionId 
     * @return RequestConfig
     */
    fun apiV2WorkItemsIdVersionVersionIdActualPostRequestConfig(id: java.util.UUID, versionId: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/workItems/{id}/version/{versionId}/actual".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"versionId"+"}", encodeURIComponent(versionId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/v2/workItems/links/urls/search
     * 
     * 
     * @param skip Amount of items to be skipped (offset) (optional)
     * @param take Amount of items to be taken (limit) (optional)
     * @param orderBy SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC) (optional)
     * @param searchField Property name for searching (optional)
     * @param searchValue Value for searching (optional)
     * @param workItemLinkUrlApiModel  (optional)
     * @return SearchWorkItemLinkUrlsApiResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2WorkItemsLinksUrlsSearchPost(skip: kotlin.Int? = null, take: kotlin.Int? = null, orderBy: kotlin.String? = null, searchField: kotlin.String? = null, searchValue: kotlin.String? = null, workItemLinkUrlApiModel: WorkItemLinkUrlApiModel? = null) : SearchWorkItemLinkUrlsApiResult {
        val localVarResponse = apiV2WorkItemsLinksUrlsSearchPostWithHttpInfo(skip = skip, take = take, orderBy = orderBy, searchField = searchField, searchValue = searchValue, workItemLinkUrlApiModel = workItemLinkUrlApiModel)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SearchWorkItemLinkUrlsApiResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/v2/workItems/links/urls/search
     * 
     * 
     * @param skip Amount of items to be skipped (offset) (optional)
     * @param take Amount of items to be taken (limit) (optional)
     * @param orderBy SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC) (optional)
     * @param searchField Property name for searching (optional)
     * @param searchValue Value for searching (optional)
     * @param workItemLinkUrlApiModel  (optional)
     * @return ApiResponse<SearchWorkItemLinkUrlsApiResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2WorkItemsLinksUrlsSearchPostWithHttpInfo(skip: kotlin.Int?, take: kotlin.Int?, orderBy: kotlin.String?, searchField: kotlin.String?, searchValue: kotlin.String?, workItemLinkUrlApiModel: WorkItemLinkUrlApiModel?) : ApiResponse<SearchWorkItemLinkUrlsApiResult?> {
        val localVariableConfig = apiV2WorkItemsLinksUrlsSearchPostRequestConfig(skip = skip, take = take, orderBy = orderBy, searchField = searchField, searchValue = searchValue, workItemLinkUrlApiModel = workItemLinkUrlApiModel)

        return request<WorkItemLinkUrlApiModel, SearchWorkItemLinkUrlsApiResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2WorkItemsLinksUrlsSearchPost
     *
     * @param skip Amount of items to be skipped (offset) (optional)
     * @param take Amount of items to be taken (limit) (optional)
     * @param orderBy SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC) (optional)
     * @param searchField Property name for searching (optional)
     * @param searchValue Value for searching (optional)
     * @param workItemLinkUrlApiModel  (optional)
     * @return RequestConfig
     */
    fun apiV2WorkItemsLinksUrlsSearchPostRequestConfig(skip: kotlin.Int?, take: kotlin.Int?, orderBy: kotlin.String?, searchField: kotlin.String?, searchValue: kotlin.String?, workItemLinkUrlApiModel: WorkItemLinkUrlApiModel?) : RequestConfig<WorkItemLinkUrlApiModel> {
        val localVariableBody = workItemLinkUrlApiModel
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (skip != null) {
                    put("Skip", listOf(skip.toString()))
                }
                if (take != null) {
                    put("Take", listOf(take.toString()))
                }
                if (orderBy != null) {
                    put("OrderBy", listOf(orderBy.toString()))
                }
                if (searchField != null) {
                    put("SearchField", listOf(searchField.toString()))
                }
                if (searchValue != null) {
                    put("SearchValue", listOf(searchValue.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/workItems/links/urls/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/v2/workItems/move
     * Move WorkItem to another section
     *   Use case    User sets WorkItem identifier    User runs method execution    System move WorkItem to another section
     * @param workItemMovePostModel  (optional)
     * @return WorkItemShortModel
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2WorkItemsMovePost(workItemMovePostModel: WorkItemMovePostModel? = null) : WorkItemShortModel {
        val localVarResponse = apiV2WorkItemsMovePostWithHttpInfo(workItemMovePostModel = workItemMovePostModel)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as WorkItemShortModel
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/v2/workItems/move
     * Move WorkItem to another section
     *   Use case    User sets WorkItem identifier    User runs method execution    System move WorkItem to another section
     * @param workItemMovePostModel  (optional)
     * @return ApiResponse<WorkItemShortModel?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2WorkItemsMovePostWithHttpInfo(workItemMovePostModel: WorkItemMovePostModel?) : ApiResponse<WorkItemShortModel?> {
        val localVariableConfig = apiV2WorkItemsMovePostRequestConfig(workItemMovePostModel = workItemMovePostModel)

        return request<WorkItemMovePostModel, WorkItemShortModel>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2WorkItemsMovePost
     *
     * @param workItemMovePostModel  (optional)
     * @return RequestConfig
     */
    fun apiV2WorkItemsMovePostRequestConfig(workItemMovePostModel: WorkItemMovePostModel?) : RequestConfig<WorkItemMovePostModel> {
        val localVariableBody = workItemMovePostModel
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/workItems/move",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/v2/workItems
     * Creates work item
     * 
     * @param createWorkItemApiModel  (optional)
     * @return WorkItemApiResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2WorkItemsPost(createWorkItemApiModel: CreateWorkItemApiModel? = null) : WorkItemApiResult {
        val localVarResponse = apiV2WorkItemsPostWithHttpInfo(createWorkItemApiModel = createWorkItemApiModel)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as WorkItemApiResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/v2/workItems
     * Creates work item
     * 
     * @param createWorkItemApiModel  (optional)
     * @return ApiResponse<WorkItemApiResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2WorkItemsPostWithHttpInfo(createWorkItemApiModel: CreateWorkItemApiModel?) : ApiResponse<WorkItemApiResult?> {
        val localVariableConfig = apiV2WorkItemsPostRequestConfig(createWorkItemApiModel = createWorkItemApiModel)

        return request<CreateWorkItemApiModel, WorkItemApiResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2WorkItemsPost
     *
     * @param createWorkItemApiModel  (optional)
     * @return RequestConfig
     */
    fun apiV2WorkItemsPostRequestConfig(createWorkItemApiModel: CreateWorkItemApiModel?) : RequestConfig<CreateWorkItemApiModel> {
        val localVariableBody = createWorkItemApiModel
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/workItems",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/v2/workItems/search
     * Search for work items
     * 
     * @param skip Amount of items to be skipped (offset) (optional)
     * @param take Amount of items to be taken (limit) (optional)
     * @param orderBy SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC) (optional)
     * @param searchField Property name for searching (optional)
     * @param searchValue Value for searching (optional)
     * @param workItemSelectApiModel  (optional)
     * @return kotlin.collections.List<WorkItemShortApiResult>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2WorkItemsSearchPost(skip: kotlin.Int? = null, take: kotlin.Int? = null, orderBy: kotlin.String? = null, searchField: kotlin.String? = null, searchValue: kotlin.String? = null, workItemSelectApiModel: WorkItemSelectApiModel? = null) : kotlin.collections.List<WorkItemShortApiResult> {
        val localVarResponse = apiV2WorkItemsSearchPostWithHttpInfo(skip = skip, take = take, orderBy = orderBy, searchField = searchField, searchValue = searchValue, workItemSelectApiModel = workItemSelectApiModel)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<WorkItemShortApiResult>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/v2/workItems/search
     * Search for work items
     * 
     * @param skip Amount of items to be skipped (offset) (optional)
     * @param take Amount of items to be taken (limit) (optional)
     * @param orderBy SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC) (optional)
     * @param searchField Property name for searching (optional)
     * @param searchValue Value for searching (optional)
     * @param workItemSelectApiModel  (optional)
     * @return ApiResponse<kotlin.collections.List<WorkItemShortApiResult>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2WorkItemsSearchPostWithHttpInfo(skip: kotlin.Int?, take: kotlin.Int?, orderBy: kotlin.String?, searchField: kotlin.String?, searchValue: kotlin.String?, workItemSelectApiModel: WorkItemSelectApiModel?) : ApiResponse<kotlin.collections.List<WorkItemShortApiResult>?> {
        val localVariableConfig = apiV2WorkItemsSearchPostRequestConfig(skip = skip, take = take, orderBy = orderBy, searchField = searchField, searchValue = searchValue, workItemSelectApiModel = workItemSelectApiModel)

        return request<WorkItemSelectApiModel, kotlin.collections.List<WorkItemShortApiResult>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2WorkItemsSearchPost
     *
     * @param skip Amount of items to be skipped (offset) (optional)
     * @param take Amount of items to be taken (limit) (optional)
     * @param orderBy SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC) (optional)
     * @param searchField Property name for searching (optional)
     * @param searchValue Value for searching (optional)
     * @param workItemSelectApiModel  (optional)
     * @return RequestConfig
     */
    fun apiV2WorkItemsSearchPostRequestConfig(skip: kotlin.Int?, take: kotlin.Int?, orderBy: kotlin.String?, searchField: kotlin.String?, searchValue: kotlin.String?, workItemSelectApiModel: WorkItemSelectApiModel?) : RequestConfig<WorkItemSelectApiModel> {
        val localVariableBody = workItemSelectApiModel
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (skip != null) {
                    put("Skip", listOf(skip.toString()))
                }
                if (take != null) {
                    put("Take", listOf(take.toString()))
                }
                if (orderBy != null) {
                    put("OrderBy", listOf(orderBy.toString()))
                }
                if (searchField != null) {
                    put("SearchField", listOf(searchField.toString()))
                }
                if (searchValue != null) {
                    put("SearchValue", listOf(searchValue.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/workItems/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/v2/workItems/{sharedStepId}/references/sections
     * Get SharedStep references in sections
     *   Use case    User sets SharedStep identifier    User runs method execution    System return SharedStep references
     * @param sharedStepId 
     * @param skip Amount of items to be skipped (offset) (optional)
     * @param take Amount of items to be taken (limit) (optional)
     * @param orderBy SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC) (optional)
     * @param searchField Property name for searching (optional)
     * @param searchValue Value for searching (optional)
     * @param sharedStepReferenceSectionsQueryFilterModel  (optional)
     * @return kotlin.collections.List<SharedStepReferenceSectionModel>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2WorkItemsSharedStepIdReferencesSectionsPost(sharedStepId: java.util.UUID, skip: kotlin.Int? = null, take: kotlin.Int? = null, orderBy: kotlin.String? = null, searchField: kotlin.String? = null, searchValue: kotlin.String? = null, sharedStepReferenceSectionsQueryFilterModel: SharedStepReferenceSectionsQueryFilterModel? = null) : kotlin.collections.List<SharedStepReferenceSectionModel> {
        val localVarResponse = apiV2WorkItemsSharedStepIdReferencesSectionsPostWithHttpInfo(sharedStepId = sharedStepId, skip = skip, take = take, orderBy = orderBy, searchField = searchField, searchValue = searchValue, sharedStepReferenceSectionsQueryFilterModel = sharedStepReferenceSectionsQueryFilterModel)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<SharedStepReferenceSectionModel>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/v2/workItems/{sharedStepId}/references/sections
     * Get SharedStep references in sections
     *   Use case    User sets SharedStep identifier    User runs method execution    System return SharedStep references
     * @param sharedStepId 
     * @param skip Amount of items to be skipped (offset) (optional)
     * @param take Amount of items to be taken (limit) (optional)
     * @param orderBy SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC) (optional)
     * @param searchField Property name for searching (optional)
     * @param searchValue Value for searching (optional)
     * @param sharedStepReferenceSectionsQueryFilterModel  (optional)
     * @return ApiResponse<kotlin.collections.List<SharedStepReferenceSectionModel>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2WorkItemsSharedStepIdReferencesSectionsPostWithHttpInfo(sharedStepId: java.util.UUID, skip: kotlin.Int?, take: kotlin.Int?, orderBy: kotlin.String?, searchField: kotlin.String?, searchValue: kotlin.String?, sharedStepReferenceSectionsQueryFilterModel: SharedStepReferenceSectionsQueryFilterModel?) : ApiResponse<kotlin.collections.List<SharedStepReferenceSectionModel>?> {
        val localVariableConfig = apiV2WorkItemsSharedStepIdReferencesSectionsPostRequestConfig(sharedStepId = sharedStepId, skip = skip, take = take, orderBy = orderBy, searchField = searchField, searchValue = searchValue, sharedStepReferenceSectionsQueryFilterModel = sharedStepReferenceSectionsQueryFilterModel)

        return request<SharedStepReferenceSectionsQueryFilterModel, kotlin.collections.List<SharedStepReferenceSectionModel>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2WorkItemsSharedStepIdReferencesSectionsPost
     *
     * @param sharedStepId 
     * @param skip Amount of items to be skipped (offset) (optional)
     * @param take Amount of items to be taken (limit) (optional)
     * @param orderBy SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC) (optional)
     * @param searchField Property name for searching (optional)
     * @param searchValue Value for searching (optional)
     * @param sharedStepReferenceSectionsQueryFilterModel  (optional)
     * @return RequestConfig
     */
    fun apiV2WorkItemsSharedStepIdReferencesSectionsPostRequestConfig(sharedStepId: java.util.UUID, skip: kotlin.Int?, take: kotlin.Int?, orderBy: kotlin.String?, searchField: kotlin.String?, searchValue: kotlin.String?, sharedStepReferenceSectionsQueryFilterModel: SharedStepReferenceSectionsQueryFilterModel?) : RequestConfig<SharedStepReferenceSectionsQueryFilterModel> {
        val localVariableBody = sharedStepReferenceSectionsQueryFilterModel
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (skip != null) {
                    put("Skip", listOf(skip.toString()))
                }
                if (take != null) {
                    put("Take", listOf(take.toString()))
                }
                if (orderBy != null) {
                    put("OrderBy", listOf(orderBy.toString()))
                }
                if (searchField != null) {
                    put("SearchField", listOf(searchField.toString()))
                }
                if (searchValue != null) {
                    put("SearchValue", listOf(searchValue.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/workItems/{sharedStepId}/references/sections".replace("{"+"sharedStepId"+"}", encodeURIComponent(sharedStepId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/v2/workItems/{sharedStepId}/references/workItems
     * Get SharedStep references in work items
     *   Use case    User sets SharedStep identifier    User runs method execution    System return SharedStep references
     * @param sharedStepId 
     * @param skip Amount of items to be skipped (offset) (optional)
     * @param take Amount of items to be taken (limit) (optional)
     * @param orderBy SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC) (optional)
     * @param searchField Property name for searching (optional)
     * @param searchValue Value for searching (optional)
     * @param sharedStepReferencesQueryFilterModel  (optional)
     * @return kotlin.collections.List<SharedStepReferenceModel>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2WorkItemsSharedStepIdReferencesWorkItemsPost(sharedStepId: java.util.UUID, skip: kotlin.Int? = null, take: kotlin.Int? = null, orderBy: kotlin.String? = null, searchField: kotlin.String? = null, searchValue: kotlin.String? = null, sharedStepReferencesQueryFilterModel: SharedStepReferencesQueryFilterModel? = null) : kotlin.collections.List<SharedStepReferenceModel> {
        val localVarResponse = apiV2WorkItemsSharedStepIdReferencesWorkItemsPostWithHttpInfo(sharedStepId = sharedStepId, skip = skip, take = take, orderBy = orderBy, searchField = searchField, searchValue = searchValue, sharedStepReferencesQueryFilterModel = sharedStepReferencesQueryFilterModel)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<SharedStepReferenceModel>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/v2/workItems/{sharedStepId}/references/workItems
     * Get SharedStep references in work items
     *   Use case    User sets SharedStep identifier    User runs method execution    System return SharedStep references
     * @param sharedStepId 
     * @param skip Amount of items to be skipped (offset) (optional)
     * @param take Amount of items to be taken (limit) (optional)
     * @param orderBy SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC) (optional)
     * @param searchField Property name for searching (optional)
     * @param searchValue Value for searching (optional)
     * @param sharedStepReferencesQueryFilterModel  (optional)
     * @return ApiResponse<kotlin.collections.List<SharedStepReferenceModel>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2WorkItemsSharedStepIdReferencesWorkItemsPostWithHttpInfo(sharedStepId: java.util.UUID, skip: kotlin.Int?, take: kotlin.Int?, orderBy: kotlin.String?, searchField: kotlin.String?, searchValue: kotlin.String?, sharedStepReferencesQueryFilterModel: SharedStepReferencesQueryFilterModel?) : ApiResponse<kotlin.collections.List<SharedStepReferenceModel>?> {
        val localVariableConfig = apiV2WorkItemsSharedStepIdReferencesWorkItemsPostRequestConfig(sharedStepId = sharedStepId, skip = skip, take = take, orderBy = orderBy, searchField = searchField, searchValue = searchValue, sharedStepReferencesQueryFilterModel = sharedStepReferencesQueryFilterModel)

        return request<SharedStepReferencesQueryFilterModel, kotlin.collections.List<SharedStepReferenceModel>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2WorkItemsSharedStepIdReferencesWorkItemsPost
     *
     * @param sharedStepId 
     * @param skip Amount of items to be skipped (offset) (optional)
     * @param take Amount of items to be taken (limit) (optional)
     * @param orderBy SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC) (optional)
     * @param searchField Property name for searching (optional)
     * @param searchValue Value for searching (optional)
     * @param sharedStepReferencesQueryFilterModel  (optional)
     * @return RequestConfig
     */
    fun apiV2WorkItemsSharedStepIdReferencesWorkItemsPostRequestConfig(sharedStepId: java.util.UUID, skip: kotlin.Int?, take: kotlin.Int?, orderBy: kotlin.String?, searchField: kotlin.String?, searchValue: kotlin.String?, sharedStepReferencesQueryFilterModel: SharedStepReferencesQueryFilterModel?) : RequestConfig<SharedStepReferencesQueryFilterModel> {
        val localVariableBody = sharedStepReferencesQueryFilterModel
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (skip != null) {
                    put("Skip", listOf(skip.toString()))
                }
                if (take != null) {
                    put("Take", listOf(take.toString()))
                }
                if (orderBy != null) {
                    put("OrderBy", listOf(orderBy.toString()))
                }
                if (searchField != null) {
                    put("SearchField", listOf(searchField.toString()))
                }
                if (searchValue != null) {
                    put("SearchValue", listOf(searchValue.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/workItems/{sharedStepId}/references/workItems".replace("{"+"sharedStepId"+"}", encodeURIComponent(sharedStepId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/v2/workItems/sharedSteps/{sharedStepId}/references
     * Get SharedStep references
     *   Use case    User sets SharedStep identifier    User runs method execution    System return SharedStep references
     * @param sharedStepId 
     * @return kotlin.collections.List<SharedStepReferenceModel>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    @Deprecated(message = "This operation is deprecated.")
    fun apiV2WorkItemsSharedStepsSharedStepIdReferencesGet(sharedStepId: java.util.UUID) : kotlin.collections.List<SharedStepReferenceModel> {
        @Suppress("DEPRECATION")
        val localVarResponse = apiV2WorkItemsSharedStepsSharedStepIdReferencesGetWithHttpInfo(sharedStepId = sharedStepId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<SharedStepReferenceModel>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/v2/workItems/sharedSteps/{sharedStepId}/references
     * Get SharedStep references
     *   Use case    User sets SharedStep identifier    User runs method execution    System return SharedStep references
     * @param sharedStepId 
     * @return ApiResponse<kotlin.collections.List<SharedStepReferenceModel>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    @Deprecated(message = "This operation is deprecated.")
    fun apiV2WorkItemsSharedStepsSharedStepIdReferencesGetWithHttpInfo(sharedStepId: java.util.UUID) : ApiResponse<kotlin.collections.List<SharedStepReferenceModel>?> {
        @Suppress("DEPRECATION")
        val localVariableConfig = apiV2WorkItemsSharedStepsSharedStepIdReferencesGetRequestConfig(sharedStepId = sharedStepId)

        return request<Unit, kotlin.collections.List<SharedStepReferenceModel>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2WorkItemsSharedStepsSharedStepIdReferencesGet
     *
     * @param sharedStepId 
     * @return RequestConfig
     */
    @Deprecated(message = "This operation is deprecated.")
    fun apiV2WorkItemsSharedStepsSharedStepIdReferencesGetRequestConfig(sharedStepId: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/workItems/sharedSteps/{sharedStepId}/references".replace("{"+"sharedStepId"+"}", encodeURIComponent(sharedStepId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * DELETE /api/v2/workItems/{id}/autoTests
     * Delete all links AutoTests from WorkItem by Id or GlobalId
     *   Use case    User sets work item identifier    User runs method execution    System search work item by identifier    System search and delete all autotests, related to found work item    System returns no content response
     * @param id WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteAllWorkItemsFromAutoTest(id: kotlin.String) : Unit {
        val localVarResponse = deleteAllWorkItemsFromAutoTestWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * DELETE /api/v2/workItems/{id}/autoTests
     * Delete all links AutoTests from WorkItem by Id or GlobalId
     *   Use case    User sets work item identifier    User runs method execution    System search work item by identifier    System search and delete all autotests, related to found work item    System returns no content response
     * @param id WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteAllWorkItemsFromAutoTestWithHttpInfo(id: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = deleteAllWorkItemsFromAutoTestRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteAllWorkItemsFromAutoTest
     *
     * @param id WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @return RequestConfig
     */
    fun deleteAllWorkItemsFromAutoTestRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/workItems/{id}/autoTests".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * DELETE /api/v2/workItems/{id}
     * Delete Test Case, Checklist or Shared Step by Id or GlobalId
     *   Use case    User sets work item identifier    User runs method execution    System deletes work item    System returns no content response
     * @param id WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteWorkItem(id: kotlin.String) : Unit {
        val localVarResponse = deleteWorkItemWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * DELETE /api/v2/workItems/{id}
     * Delete Test Case, Checklist or Shared Step by Id or GlobalId
     *   Use case    User sets work item identifier    User runs method execution    System deletes work item    System returns no content response
     * @param id WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteWorkItemWithHttpInfo(id: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = deleteWorkItemRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteWorkItem
     *
     * @param id WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @return RequestConfig
     */
    fun deleteWorkItemRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/workItems/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/v2/workItems/{id}/autoTests
     * Get all AutoTests linked to WorkItem by Id or GlobalId
     *   Use case    User sets work item identifier    User runs method execution    System search work item by identifier    System search all autotests, related to found work item    System returns list of found autotests
     * @param id WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @return kotlin.collections.List<AutoTestModel>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAutoTestsForWorkItem(id: kotlin.String) : kotlin.collections.List<AutoTestModel> {
        val localVarResponse = getAutoTestsForWorkItemWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<AutoTestModel>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/v2/workItems/{id}/autoTests
     * Get all AutoTests linked to WorkItem by Id or GlobalId
     *   Use case    User sets work item identifier    User runs method execution    System search work item by identifier    System search all autotests, related to found work item    System returns list of found autotests
     * @param id WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @return ApiResponse<kotlin.collections.List<AutoTestModel>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAutoTestsForWorkItemWithHttpInfo(id: kotlin.String) : ApiResponse<kotlin.collections.List<AutoTestModel>?> {
        val localVariableConfig = getAutoTestsForWorkItemRequestConfig(id = id)

        return request<Unit, kotlin.collections.List<AutoTestModel>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAutoTestsForWorkItem
     *
     * @param id WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @return RequestConfig
     */
    fun getAutoTestsForWorkItemRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/workItems/{id}/autoTests".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/v2/workItems/{id}/iterations
     * Get iterations by work item Id or GlobalId
     * 
     * @param id WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @param versionId WorkItem version (guid format) identifier (optional)
     * @param versionNumber WorkItem version number (0 is the last version)\&quot; (optional)
     * @return kotlin.collections.List<IterationModel>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getIterations(id: kotlin.String, versionId: java.util.UUID? = null, versionNumber: kotlin.Int? = null) : kotlin.collections.List<IterationModel> {
        val localVarResponse = getIterationsWithHttpInfo(id = id, versionId = versionId, versionNumber = versionNumber)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<IterationModel>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/v2/workItems/{id}/iterations
     * Get iterations by work item Id or GlobalId
     * 
     * @param id WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @param versionId WorkItem version (guid format) identifier (optional)
     * @param versionNumber WorkItem version number (0 is the last version)\&quot; (optional)
     * @return ApiResponse<kotlin.collections.List<IterationModel>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getIterationsWithHttpInfo(id: kotlin.String, versionId: java.util.UUID?, versionNumber: kotlin.Int?) : ApiResponse<kotlin.collections.List<IterationModel>?> {
        val localVariableConfig = getIterationsRequestConfig(id = id, versionId = versionId, versionNumber = versionNumber)

        return request<Unit, kotlin.collections.List<IterationModel>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getIterations
     *
     * @param id WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @param versionId WorkItem version (guid format) identifier (optional)
     * @param versionNumber WorkItem version number (0 is the last version)\&quot; (optional)
     * @return RequestConfig
     */
    fun getIterationsRequestConfig(id: kotlin.String, versionId: java.util.UUID?, versionNumber: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (versionId != null) {
                    put("versionId", listOf(versionId.toString()))
                }
                if (versionNumber != null) {
                    put("versionNumber", listOf(versionNumber.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/workItems/{id}/iterations".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/v2/workItems/{id}
     * Get Test Case, Checklist or Shared Step by Id or GlobalId
     *   Use case    User sets work item identifier    [Optional] User sets work item version identifier    [Optional] User sets work item version number    User runs method execution    System search work item by identifier    [Optional] if User sets work item version identifier, system search work item version by identifier.    [Optional] if user sets work item version number, system search work item version by number    Otherwise, system search last work item version    System returns work item
     * @param id WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @param versionId WorkItem version (guid format) identifier\&quot; (optional)
     * @param versionNumber WorkItem version number (0 is the last version)\&quot; (optional)
     * @return WorkItemModel
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getWorkItemById(id: kotlin.String, versionId: java.util.UUID? = null, versionNumber: kotlin.Int? = null) : WorkItemModel {
        val localVarResponse = getWorkItemByIdWithHttpInfo(id = id, versionId = versionId, versionNumber = versionNumber)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as WorkItemModel
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/v2/workItems/{id}
     * Get Test Case, Checklist or Shared Step by Id or GlobalId
     *   Use case    User sets work item identifier    [Optional] User sets work item version identifier    [Optional] User sets work item version number    User runs method execution    System search work item by identifier    [Optional] if User sets work item version identifier, system search work item version by identifier.    [Optional] if user sets work item version number, system search work item version by number    Otherwise, system search last work item version    System returns work item
     * @param id WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @param versionId WorkItem version (guid format) identifier\&quot; (optional)
     * @param versionNumber WorkItem version number (0 is the last version)\&quot; (optional)
     * @return ApiResponse<WorkItemModel?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getWorkItemByIdWithHttpInfo(id: kotlin.String, versionId: java.util.UUID?, versionNumber: kotlin.Int?) : ApiResponse<WorkItemModel?> {
        val localVariableConfig = getWorkItemByIdRequestConfig(id = id, versionId = versionId, versionNumber = versionNumber)

        return request<Unit, WorkItemModel>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getWorkItemById
     *
     * @param id WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @param versionId WorkItem version (guid format) identifier\&quot; (optional)
     * @param versionNumber WorkItem version number (0 is the last version)\&quot; (optional)
     * @return RequestConfig
     */
    fun getWorkItemByIdRequestConfig(id: kotlin.String, versionId: java.util.UUID?, versionNumber: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (versionId != null) {
                    put("versionId", listOf(versionId.toString()))
                }
                if (versionNumber != null) {
                    put("versionNumber", listOf(versionNumber.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/workItems/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/v2/workItems/{id}/chronology
     * Get WorkItem chronology by Id or GlobalId
     *   Use case    User sets work item identifier    User runs method execution    System search work item by identifier    System search test results of all autotests, related to found work item    System sort results by CompletedOn ascending, then by CreatedDate ascending    System returns sorted collection of test results
     * @param id 
     * @return kotlin.collections.List<TestResultChronologyModel>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    @Deprecated(message = "This operation is deprecated.")
    fun getWorkItemChronology(id: kotlin.String) : kotlin.collections.List<TestResultChronologyModel> {
        @Suppress("DEPRECATION")
        val localVarResponse = getWorkItemChronologyWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<TestResultChronologyModel>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/v2/workItems/{id}/chronology
     * Get WorkItem chronology by Id or GlobalId
     *   Use case    User sets work item identifier    User runs method execution    System search work item by identifier    System search test results of all autotests, related to found work item    System sort results by CompletedOn ascending, then by CreatedDate ascending    System returns sorted collection of test results
     * @param id 
     * @return ApiResponse<kotlin.collections.List<TestResultChronologyModel>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    @Deprecated(message = "This operation is deprecated.")
    fun getWorkItemChronologyWithHttpInfo(id: kotlin.String) : ApiResponse<kotlin.collections.List<TestResultChronologyModel>?> {
        @Suppress("DEPRECATION")
        val localVariableConfig = getWorkItemChronologyRequestConfig(id = id)

        return request<Unit, kotlin.collections.List<TestResultChronologyModel>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getWorkItemChronology
     *
     * @param id 
     * @return RequestConfig
     */
    @Deprecated(message = "This operation is deprecated.")
    fun getWorkItemChronologyRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/workItems/{id}/chronology".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/v2/workItems/{id}/versions
     * Get WorkItem versions
     *   Use case    User sets work item identifier    [Optional] User sets work item version identifier    User runs method execution    System search work item by identifier    [Optional] If User set work item version identifier, System search work item version by version identifier                      Otherwise, system search all version of work item    System returns array of work item version models (listed in response example)
     * @param id WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @param workItemVersionId WorkItem version (guid format)  identifier\&quot; (optional)
     * @param versionNumber WorkItem version (integer format)  number\&quot; (optional)
     * @return kotlin.collections.List<WorkItemVersionModel>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getWorkItemVersions(id: kotlin.String, workItemVersionId: java.util.UUID? = null, versionNumber: kotlin.Int? = null) : kotlin.collections.List<WorkItemVersionModel> {
        val localVarResponse = getWorkItemVersionsWithHttpInfo(id = id, workItemVersionId = workItemVersionId, versionNumber = versionNumber)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<WorkItemVersionModel>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/v2/workItems/{id}/versions
     * Get WorkItem versions
     *   Use case    User sets work item identifier    [Optional] User sets work item version identifier    User runs method execution    System search work item by identifier    [Optional] If User set work item version identifier, System search work item version by version identifier                      Otherwise, system search all version of work item    System returns array of work item version models (listed in response example)
     * @param id WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @param workItemVersionId WorkItem version (guid format)  identifier\&quot; (optional)
     * @param versionNumber WorkItem version (integer format)  number\&quot; (optional)
     * @return ApiResponse<kotlin.collections.List<WorkItemVersionModel>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getWorkItemVersionsWithHttpInfo(id: kotlin.String, workItemVersionId: java.util.UUID?, versionNumber: kotlin.Int?) : ApiResponse<kotlin.collections.List<WorkItemVersionModel>?> {
        val localVariableConfig = getWorkItemVersionsRequestConfig(id = id, workItemVersionId = workItemVersionId, versionNumber = versionNumber)

        return request<Unit, kotlin.collections.List<WorkItemVersionModel>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getWorkItemVersions
     *
     * @param id WorkItem internal (guid format) or  global(integer format) identifier\&quot;
     * @param workItemVersionId WorkItem version (guid format)  identifier\&quot; (optional)
     * @param versionNumber WorkItem version (integer format)  number\&quot; (optional)
     * @return RequestConfig
     */
    fun getWorkItemVersionsRequestConfig(id: kotlin.String, workItemVersionId: java.util.UUID?, versionNumber: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (workItemVersionId != null) {
                    put("workItemVersionId", listOf(workItemVersionId.toString()))
                }
                if (versionNumber != null) {
                    put("versionNumber", listOf(versionNumber.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/workItems/{id}/versions".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/v2/workItems/{id}/purge
     * Permanently delete test case, checklist or shared steps from archive
     * 
     * @param id Unique or global ID of the work item
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun purgeWorkItem(id: kotlin.String) : Unit {
        val localVarResponse = purgeWorkItemWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/v2/workItems/{id}/purge
     * Permanently delete test case, checklist or shared steps from archive
     * 
     * @param id Unique or global ID of the work item
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun purgeWorkItemWithHttpInfo(id: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = purgeWorkItemRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation purgeWorkItem
     *
     * @param id Unique or global ID of the work item
     * @return RequestConfig
     */
    fun purgeWorkItemRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/workItems/{id}/purge".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/v2/workItems/{id}/restore
     * Restore test case, checklist or shared steps from archive
     * 
     * @param id Unique or global ID of the work item
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun restoreWorkItem(id: kotlin.String) : Unit {
        val localVarResponse = restoreWorkItemWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/v2/workItems/{id}/restore
     * Restore test case, checklist or shared steps from archive
     * 
     * @param id Unique or global ID of the work item
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun restoreWorkItemWithHttpInfo(id: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = restoreWorkItemRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation restoreWorkItem
     *
     * @param id Unique or global ID of the work item
     * @return RequestConfig
     */
    fun restoreWorkItemRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/workItems/{id}/restore".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * PUT /api/v2/workItems
     * Update Test Case, Checklist or Shared Step
     *   Use case    User sets work item properties (listed in request parameters)    User runs method execution    System updates work item by identifier    System returns updated work item model (listed in response parameters)
     * @param updateWorkItemApiModel  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateWorkItem(updateWorkItemApiModel: UpdateWorkItemApiModel? = null) : Unit {
        val localVarResponse = updateWorkItemWithHttpInfo(updateWorkItemApiModel = updateWorkItemApiModel)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * PUT /api/v2/workItems
     * Update Test Case, Checklist or Shared Step
     *   Use case    User sets work item properties (listed in request parameters)    User runs method execution    System updates work item by identifier    System returns updated work item model (listed in response parameters)
     * @param updateWorkItemApiModel  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun updateWorkItemWithHttpInfo(updateWorkItemApiModel: UpdateWorkItemApiModel?) : ApiResponse<Unit?> {
        val localVariableConfig = updateWorkItemRequestConfig(updateWorkItemApiModel = updateWorkItemApiModel)

        return request<UpdateWorkItemApiModel, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateWorkItem
     *
     * @param updateWorkItemApiModel  (optional)
     * @return RequestConfig
     */
    fun updateWorkItemRequestConfig(updateWorkItemApiModel: UpdateWorkItemApiModel?) : RequestConfig<UpdateWorkItemApiModel> {
        val localVariableBody = updateWorkItemApiModel
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v2/workItems",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
